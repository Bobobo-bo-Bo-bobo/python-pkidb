#!/usr/bin/env python -W ignore::DeprecationWarning
#
# This version is
#   Copyright (C) 2015 Andreas Maus
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program. If not, see <https://www.gnu.org/licenses/>.
#


import pkidbbackends
import base64
import getopt
import json
import logging
import logging.handlers
import math
import os
import re
import sys
import time
import OpenSSL

# default configuration file
configfile = "/etc/pkidb/config.ini"

__version__ = "0.8.12.3"

shortoptions = {
    "main": "c:hV",
    "sign": "b:o:s:v:E:S:k:K:t:",
    "import": "c:r:a:p:d:",
    "housekeeping": "ap:",
    "statistics": "",
    "gencrl": "o:",
    "revoke": "fr:R:",
    "renew": "o:p:",
    "export": "o:",
    "remove": "",
    "backup": "o:",
    "list": "eiho:rtv",
    "restore": "",
    "delete": "",
    "show": "o:",
    "set": "aAP:V:",
    "healthcheck": "f",
    "add-dummy": "s:e:S:",
    "search": "",
}

longoptions = {
    "main": ["config=", "help", "version"],
    "sign": ["output=", "start-in=", "valid-for=", "extension=", "san=", "keyusage=", "extended-keyusage=",
             "basic-constraint=", "template="],
    "import": ["csr=", "revoked=", "auto-renew", "period=", "delta="],
    "housekeeping": ["auto-renew", "period="],
    "statistics": [],
    "gencrl": ["output="],
    "revoke": ["force", "reason=", "revocation-date="],
    "renew": ["output=", "period="],
    "export": ["output="],
    "remove": [],
    "backup": ["output="],
    "list": ["expired", "hex", "invalid", "output=", "revoked", "temporary", "valid"],
    "restore": [],
    "delete": [],
    "show": ["output="],
    "set": ["auto-renew", "no-auto-renew", "auto-renew-start-period=", "auto-renew-validty-period="],
    "healthcheck": ["fix"],
    "add-dummy": ["start=", "end=", "subject="],
    "search": [],
}

__logger = None

# Python 3 renamed ConfigParser to configparser
if sys.version_info[0] < 3:
    import ConfigParser as configparser
else:
    import configparser


def mapconfigsections(config, section):
    """
    helper function to map ini sections and values
    :param config:  ConfigParser object
    :param section: section to parse
    :return:
    """
    resdict = {}
    options = config.options(section)

    for opt in options:
        try:
            resdict[opt] = config.get(section, opt)
            if resdict[opt] == -1:
                # skip option, remove from dictionary
                resdict.pop(opt)
        except configparser.Error as error:
            sys.stderr.write("Error: Error parsing ini file: %s\n" % (error.message,))
            return None
    return resdict

def parseoptions(optfile):
    """
    Parses an "ini style" option file, returns result
    as dictionary
    :param optfile: optionfile to parse
    :return: parsed options
    """
    result = {}
    config = configparser.ConfigParser()
    config.read(optfile)
    # loop over sections
    try:
        for section in config.sections():
            result[section] = mapconfigsections(config, section)
    except configparser.Error as error:
        sys.stderr.write("Error: Can't parse ini file %s: %s\n" % (optfile, error.message))
        result = None
    return result

def usage():
    version()

    print("""Usage: %s [-c <cfg>|--config=<cfg>] [-h|--help] <command> [<commandoptions>]

  -V                                        Shows version.
  --version

  -c <cfg>                                  Use configuration file instead of the default
  --config=<cfg>                            Default: %s

  -h                                        This text
  --help

  Commands:

   add-dummy                                Add a dummy certificate identified by the serial number.
                                            If the serial number is not given on the command line it will be
                                            read from standard input.
                                            This can be used if the certificate has been issued but the certificate
                                            file is not present (e.g. during a migration) but the serial number
                                            and optionally the start date, end date or subject is known.

     -S <subject>                           Certificate subject.
     --subject=<subject>

     -s <start>                             Start of the certificates validity period.
     --start=<start>                        <start> is the UNIX epoch of the revocation or ASN1 GERNERALIZEDTIME
                                            string in the format YYYYMMDDhhmmssZ

     -e <end>                               End of the certificates validity period.
     --end=<end>                            <end> is the UNIX epoch of the revocation or ASN1 GERNERALIZEDTIME
                                            string in the format YYYYMMDDhhmmssZ

   backup                                   Dumps the content of the backend database in JSON format.
                                            This can be used to backup the PKI database and is the only
                                            supported way to migrate between different backend types.
                                            If no output file (option -o) has been given it will be written
                                            to standard output.

     -o <output>                            Write database dump to <output> instead of standard out.
     --output=<output>

   delete                                   Deletes a certificate identified by the serial number.
                                            If the serial number is not given on the command line it will be
                                            read from standard input.

   export                                   Dumps base64 encoded X509 data of a certificate (aka PEM format).
                                            The serial number of the certificate must be given.
                                            If not given it will be read from the standard input.
                                            The certificate will be written to standard output or to a file if
                                            the -o option is used.

     -o <output>                            Write certificate to <output> instead of standard out.
     --output=<output>

   gencrl                                   Generate certificate revocation list containing information about revoked
                                            certificates. The certificate revocation list will be written to standard
                                            output or to a file if -o is used.

     -o <output>                            Write revocation list to <output> instead of standard output.
     --output=<output>

   healthcheck                              Verify integrity of the stored certifiate data.

   -f                                       Fix errors. Stored data will be replaced with data from the certifiate
   --fix                                    stored in the database.

   housekeeping                             General "housekeeping. Checking all certificates in the database
                                            for expiration, renew auto renewable certificates (if option -A is used).
                                            This should be run at regular intervals.

     -a                                     Renew auto renawable certificates that will expire.
     --auto-renew

     -p <period>                            New validity period for auto renewed certificate.
     --period=<period>                      Default is the value given on import that has been stored in the backend.

   import                                   Import a certificate. If a file name is given it will be read
                                            from the file, otherwise it will be read from stdin.

     -a                                     Mark certificate as autorenwable.
     --auto-renew                           The "housekeeping" command will take care of this

     -c <csr>                               Certificate signing request used for certificate
     --csr=<csr>                            creation. Optional.

     -d <delta_period>                      For auto renewable certificates the auto renew process starts if the time
     --delta=<delta_period>                 til expiration is less than <delta_period> days.

     -p <period>                            New validity period for auto renewed certificate.
     --period=<period>                      Default is the value given in the configuration file as validity_period.

     -r <reason>,<time>                     Mark certificate as revoked. Optional.
     --revoked=<reason>,<time>              <time> is the UNIX epoch of the revocation or ASN1 GERNERALIZEDTIME
                                            string in the format YYYYMMDDhhmmssZ
                                            <reason> can be one of:
                                            unspecified, keyCompromise, CACompromise, affiliationChanged,
                                            superseded, cessationOfOperation, certificateHold, privilegeWithdrawn,
                                            removeFromCRL, aACompromise

   list                                     List serial numbers of certificates.
                                            The list will be written to standard out if the option -o is not used.

     -e                                     List serial numbers of expired certificates.
     --expired

     -i                                     List serial numbers of invalid certificates.
     --invalid                              Certficates are considered invalid if their notBefore time is in the future.

     -h                                     Print serial number as hexadecimal number
     --hex

     -o <output>                            Write serial numbers of listed certificate to <output> instead of stdout
     --output=<output>

     -r                                     List serial numbers of revoked certificates.
     --revoked

     -t                                     List "certificates" marked as temporary
     --temporary                            Temporary certficates are dummy settings used to "lock" serial numbers
                                            during signing of a certificate signing request.

     -v                                     List serial numbers of valid certificates.
     --valid                                Certificates are considered valid if they are not temporary, not revoked
                                            and the validity period (notBefore .. notAfter) has been started and the
                                            certificates is not expired.

   renew                                    Renew a cerificate. The serial number of the certificate must be given.
                                            If not given it will be read from the standard input.
                                            The new certificate will be written to standard output or to a file if
                                            the -o option is used.

     -o <output>                            Write new certificate to <output> instead of standard out
     --output=<output>

     -p <period>                            New validity period for renewed certificate.
     --period=<period>                      Default <validity_period> from configuration file.

   restore                                  Restores database from a JSON file generated with the backup command.
                                            If the filename of the input data is given on the command line it
                                            will be read, otherwise input will be read from standard input

   revoke                                   Revoke a certificate. Serial number of the certificate to revoke must
                                            be used. If not given on the command line it will be read from
                                            stdin.

     -f                                     Revoke certificate by it's serial number event it is not present in the
     --force                                database. A dummy entry will be inserted in the database and marked as revoked.

     -r <reason>                            Set revocation reason for certificate.
     --reason=<reason>                      <reason> can be one of:
                                            unspecified, keyCompromise, CACompromise, affiliationChanged,
                                            superseded, cessationOfOperation, certificateHold, privilegeWithdrawn,
                                            removeFromCRL, aACompromise
                                            If no reasen is given, the default "unspecified" is used.

     -R <date>                              Set revocation date for certificate.
     --revocation-date=<date>               <revdate> is the UNIX epoch of the revocation or ASN1 GERNERALIZEDTIME
                                            string in the format YYYYMMDDhhmmssZ.
                                            If not given, the current date will be used.

   search                                   Search certificate subject for a given string. Search string can be given
                                            on the command line. If omitted it will be read from standard input.
                                            SQL wildcards like %% can be used. The serial numbers matching the search
                                            will be printed to standard output.

   set                                      Modify meta data of a certificate identified by the serial number.
                                            The serial number of the certificate must be given on the command line or
                                            will be read from the standard input.

     -A                                     Mark a certificate as auto renewable.
     --auto-renew

     -P <period>                            Set auto renew start period in days. If there are less than <period> days
     --auto-renew-start-period=<period>     left until certificate expiration it will be renewed. The "housekeeping"
                                            command will renew the certificate.

     -V                                     Renew the certificate for <period> days. If not specified the setting
     --auto-renew-validity-period=<period>  from the configuration file will be used.

     -a                                     Remove auto renewable flag from certificate meta data.
     --no-auto-renew

   show                                     Shows information of a certificate identified by the serial number.
                                            The serial number of the certificate must be given on the command line or
                                            will be read from the standard input.
                                            The certificate information will be written to standard output or to a
                                            file if the -o option is used.

     -o <output>                            Write new certificate information to <output> instead of standard output.
     --output=<output>

   sign                                     Sign a certificate signing request. If a file name is given it will be
                                            read, otherwise it will be read from stdin. Output will be written to
                                            stdout or to a file if -o option is used.

     -E <extdata>                           X509 extension. Can be repeated for multiple extensions.
     --extension=<extdata>                  Parameter <extdata> is a comma separated list of:
                                            <name> - Name of the X509 extension
                                            <critical> - Critical flag. 0: False, 1: True
                                            <subject> - Subject, is usually empty
                                            <issuer> - Issuer, is usually empty
                                            <data> - data of the extension

     -K [critical:]:<flags>                 Comma separated list of extended key usage bits.
     --extended-keyusage=[critical:]<flags> Prefix critical: can be used to set the critical flag.
                                            Additionally dotted numeric OID are allowed too, e.g. 1.2.3.4.5
                                            Known extended key usage bits are (defined in RFC 55280):
                                            serverAuth, clientAuth, codeSigning, emailProtection, timeStamping,
                                            msCodeInd, msCodeCom, msCTLSign, msSGC, msEFS, nsSGC


     -S [critical:]<san>                    subjectAltName extension. Prefix critical: can be used to set the critical
     --san=[critical:]<san>                 flag on the alternate name list (default: False).
                                            This is the same as --extension=subjectAltName,[0|1],,,<san>
                                            but as using the subjectAltName extension is the
                                            most common extension this is an extra option.

     -a                                     Mark certificate as auto renewable.
     --auto-renew                           The "housekeeping" command will take care of this

     -b critical:<data>                     Set basic constraints Prefix critical: can be used to set the critical
     --basic-constraint=critical:]<data>    flag on the basic constraints, e.g. -b critical:CA:TRUE,pathlen:1 for
                                            a CA certificate with a maximal path length of 1.

     -k [critical:]<flags>                  Comma separated list of keyUsage bits. Prefix critical: can be used to set
     --keyusage=[critical:]<flags>          the critical flag. Known keyUsage bits according to RFC 5280 are:
                                            digitalSignature, nonRepudiation (or contentCommitment), keyEncipherment,
                                            dataEncipherment, keyAgreement, keyCertSign, cRLSign, encipherOnly,
                                            decipherOnly (see RFC 5280, Section 4.2.1.3 "Key Usage" for futher details).

     -o <out>                               Write data to <outfile> instead of stdout
     --output=<out>

     -s <start>                             Validity of the new certificate starts in startin days.
     --start-in=<start>                     Default: now

     -t <template>                          Use a template file for certificate signing.
     --template=<template>

     -v <validfor>                          New certificate will be valid for validfor days.
     --valid-for=<validfor>                 Default ist the defined validity_period in the configuration or the
                                            template file.

   statistics                               Print small summary of stored certificates. Output will be written to
                                            stdout.

  """ % (os.path.basename(sys.argv[0]), configfile))

# uniqify a list but preserve the order
# http://www.peterbe.com/plog/uniqifiers-benchmark
def remove_duplicates(list):
    ordered = []

    for entry in list:
      if entry not in ordered:
        ordered.append(entry)

    return ordered

def list_certificates(opts, config, backend):
    """
    List certificates from backend
    :param opts: options
    :param config: configuration
    :param backend: backend
    :return:
    """
    output = None
    snfilter = []
    hexadecimal = False

    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["list"], longoptions["list"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg))

    for (opt, val) in optval:
        if opt in ("-o", "--output"):
            output = val
        elif opt in ("-e", "--expired"):
            snfilter.append("expired")
        elif opt in ("-i", "--invalid"):
            snfilter.append("invalid")
        elif opt in ("-h", "--hex"):
            hexadecimal = True
        elif opt in ("-r", "--revoked"):
            snfilter.append("revoked")
        elif opt in ("-t", "--temporary"):
            snfilter.append("temporary")
        elif opt in ("-v", "--valid"):
            snfilter.append("valid")
        else:
            __logger.error("Unknown option %s" % (opt,))
            raise pkidbbackends.PKIDBException(message="Error: Unknown option %s" % (opt,))

    serials = []
    if len(snfilter) == 0:
        serials = backend.list_serial_number_by_state(None)
    else:
        for state in snfilter:
            serials += backend.list_serial_number_by_state(state)

    serials = remove_duplicates(serials)
    if hexadecimal:
        for i in range(len(serials)):
            serials[i] = "0x%.02x" % (long(serials[i]), )

    sn_dump = '\n'.join(serials)
    if output:
        try:
            fd = open(output, "w")
            fd.write(sn_dump)
            fd.close()
        except IOError as error:
            __logger.error("Can't write to output file %s: %s" % (output, error.strerror))
            raise pkidbbackends.PKIDBException(message="Can't write to output file %s: %s" % (output, error.strerror))
    else:
        sys.stdout.write(sn_dump+'\n')

def backup_database(opts, config, backend):
    """
    Exports the database backend as JSON
    :param opts: options
    :param config: configuration
    :param backend: backend
    :return:
    """
    output = None

    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["backup"], longoptions["backup"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg, ))

    for (opt, val) in optval:
        if opt in ("-o", "--output"):
            output = val
        else:
            __logger.error("Unknown option %s" % (opt,))
            raise pkidbbackends.PKIDBException(message="Error: Unknown option %s\n" % (opt,))

    dump = backend.dump_database()
    if not dump:
        __logger.warning("Database dump is empty")
        return None

    json_dump = json.dumps(dump)
    if output:
        try:
            fd = open(output, "w")
            fd.write(json_dump)
            fd.close()
        except IOError as error:
            __logger.error("Can't write to output file %s: %s" % (output, error.strerror))
            raise pkidbbackends.PKIDBException(message="Can't write to output file %s: %s" % (output, error.strerror))
    else:
        sys.stdout.write(json_dump+"\n")

def healthcheck(opts, config, backend):
    fix = False

    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["healthcheck"], longoptions["healthcheck"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg, ))

    for (opt, val) in optval:
        if opt in ("-f", "--fix"):
            fix = True
        else:
            __logger.error("Unknown option %s" % (opt,))
            raise pkidbbackends.PKIDBException(message="Unknown option %s" % (opt, ))

    result = backend.healthcheck(fix)

    total = len(result[0]) + len(result[1]) + len(result[2])
    found = len(result[1])
    repaired = len(result[2])

    __logger.info("%u certificates checked, %u problems found, %u problems repaired" % (total, found, repaired))

def restore_database(opts, config, backend):
    """
    Restore a database from JSON dump
    :param opts: options
    :param config: configuration
    :param backend: backend
    :return:
    """
    input = None
    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["restore"], longoptions["restore"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg, ))

    for (opt, val) in optval:
        pass

    if len(trailing) == 1:
        input = trailing[0]

    json_data = None
    if input:
        try:
            fd = open(input, "r")
            json_data = fd.read()
            fd.close()
        except IOError as error:
            __logger.error("Can't read from input file %s: %s" % (input, error.strerror))
            raise pkidbbackends.PKIDBException(message="Can't read from input file %s: %s" % (input, error.strerror))

    else:
        json_data = sys.stdin.read()

    # convert JSON to data strucuture
    if json_data:
        try:
            data = json.loads(json_data)
        except ValueError as error:
            __logger.error("Input is not valid JSON format: %s" % (error.message, ))
            raise pkidbbackends.PKIDBException(message="Input is not valid JSON format: %s" % (error.message, ))

        backend.restore_database(data)

def set_certificate_metadata(opts, config, backend):
    """
    Set certificate meta data in the backend.
    :param opts: options
    :param config: configuration
    :param backend: backend
    :return:
    """

    auto_renew=None
    auto_renew_start_period = None
    auto_renew_validity_period = None

    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["set"], longoptions["set"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg, ))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg, ))

    for (opt, val) in optval:
        if opt in ("-A", "--auto-renew"):
            auto_renew = True
        elif opt in ("-a", "--no-auto-renew"):
            auto_renew = False
        elif opt in ("-P", "--auto-renew-start-period"):
            try:
                auto_renew_start_period = float(val)
            except ValueError as error:
                __logger.error("Can't convert option to a number: %s" % (error.message, ))
                raise pkidbbackends.PKIDBException(message="Can't convert option to a number: %s" % (error.message, ))

        elif opt in ("-V", "--auto-renew-validty-period"):
            try:
                auto_renew_validity_period = float(val)
            except ValueError as error:
                __logger.error("Can't convert option to a number: %s" % (error.message, ))
                raise pkidbbackends.PKIDBException("Can't convert option to a number: %s" % (error.message, ))

        else:
            __logger.error("Unknown option %s" % (opt,))
            raise pkidbbackends.PKIDBException(message="Unknown option %s" % (opt, ))

    serial = None
    if len(trailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = trailing[0]

    serial = serial_to_number(serial)
    cert = backend.set_certificate_metadata(serial, auto_renew=auto_renew,
                                            auto_renew_start_period=auto_renew_start_period,
                                            auto_renew_validity_period=auto_renew_validity_period)
    if not cert:
        __logger.error("No certificate with serial number %s found" % (serial, ))
        raise pkidbbackends.PKIDBException(message="No certificate with serial number %s found" % (serial, ))

def export_certificate(opts, config, backend):
    """
    Export a certificate identified by the serial number
    :param opts: options
    :param config: configuration
    :param backend: backend
    :return:
    """
    output = None

    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["export"], longoptions["export"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg, ))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg, ))

    for (opt, val) in optval:
        if opt in ("-o", "--output"):
            output = val
        else:
            __logger.error("Unknown option %s" % (opt,))
            raise pkidbbackends.PKIDBException("Unknown option %s" % (opt, ))

    serial = None
    if len(trailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = trailing[0]

    serial = serial_to_number(serial)
    cert = backend.get_certificate(serial)

    if not cert:
        __logger.error("No certificate with serial number %s found" % (serial, ))
        raise pkidbbackends.PKIDBException(message="No certificate with serial number %s found\n" % (serial, ))

    pem_data = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)

    if output:
        try:
            fd = open(output, "w")
            fd.write(pem_data)
            fd.close()
        except IOError as error:
            __logger.error("Can't write to output file %s: %s" % (output, error.strerror))
            raise pkidbbackends.PKIDBException(message="Can't write to output file %s: %s" % (output, error.strerror))

    else:
        sys.stdout.write(pem_data)

def show_certificate(opts, config, backend):
    """
    Shows certificate information identified by the serial number
    :param opts: options
    :param config: configuration
    :param backend: backend
    :return:
    """
    output = None

    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["show"], longoptions["show"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg, ))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg, ))

    for (opt, val) in optval:
        if opt in ("-o", "--output"):
            output = val
        else:
            __logger.error("Unknown option %s" % (opt,))
            raise pkidbbackends.PKIDBException(message="Unknown option %s" % (opt, ))

    serial = None
    if len(trailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = trailing[0]

    serial = serial_to_number(serial)
    certdata = backend.get_certificate_data(serial)

    if not certdata:
        __logger.error("No certificate with serial number %s found" % (serial, ))
        raise pkidbbackends.PKIDBException(message="No certificate with serial number %s found" % (serial, ))

    string = _print_data(certdata)

    if output:
        try:
            fd = open(output, "w")
            fd.write(string)
            fd.close()
        except IOError as error:
            __logger.error("Can't write to output file %s: %s" % (output, error.strerror))
            raise pkidbbackends.PKIDBException(message="Can't write to output file %s: %s" % (output, error.strerror))

    else:
        sys.stdout.write(string)

def _print_interval(interval):
    """
    Prints interval in seconds as string
    :param interval: interval in seconds
    :return: string
    """
    string = ""

    days = math.floor(interval / 86400)
    hours = math.floor((interval - 86400 * days) / 3600)
    minutes = math.floor((interval - 86400 * days - 3600 * hours) / 60)
    seconds = math.floor(interval - 86400 * days - 3600 * hours - 60 * minutes)

    string = "%u days %u hours %u minutes %.2f seconds" % (days, hours, minutes, seconds)
    return string

def _print_data(data):
    """
    Prints certificate date obtained by get_certificate_data
    :param data:
    :return: string
    """
    revinfo = ""
    if data["state"] == "revoked":
        revinfo = "\n * Revoked on: %s\n * Revocation reason: %s" % (data["revocation_date"], data["revocation_reason"])

    auto_renew_info = ""
    if data["auto_renewable"]:
        auto_renew_info = "\n * Auto renew starts before expiration: %s\n * Auto renew for: %s" %\
                          (_print_interval(data["auto_renew_start_period"]),
                                           _print_interval(data["auto_renew_validity_period"]))

    ext_info = ""
    if len(data["extension"]) > 0:
        for i in range(len(data["extension"])):
            ext_info += "\n * Extension: %u\n  * Name: %s\n  * Critical: %s\n  * Data: %s" %\
                        (i+1, data["extension"][i]["name"], data["extension"][i]["critical"],
                         data["extension"][i]["data"])

    result = """Serial number: %s
SSL version: %u
Key size: %u
Signature algorithm: %s
State: %s%s
Begins on: %s
Ends on: %s
Subject: %s
Issuer: %s
Fingerprint (MD5): %s
Fingerprint (SHA1): %s
Auto renewable: %s%s
Extensions: %u%s
Public key: %s
Certificate signing request: %s
""" % (data["serial_number"], data["version"], data["keysize"], data["algorithm"], data["state"], revinfo,
       data["start_date"], data["end_date"], data["subject"], data["issuer"], data["fingerprint_md5"],
       data["fingerprint_sha1"], data["auto_renewable"], auto_renew_info, len(data["extension"]), ext_info,
       data["certificate"], data["signing_request"])

    return result

def delete_certificate(opts, config, backend):
    """
    Deletes a certificate identified by the serial number
    :param opts: options
    :param config: configuration
    :param backend: backend
    :return:
    """
    output = None

    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["delete"], longoptions["delete"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg, ))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg, ))

    for (opt, val) in optval:
        pass

    serial = None
    if len(trailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = trailing[0]

    serial = serial_to_number(serial)
    cert = backend.get_certificate(serial)

    if not cert:
        __logger.error("No certificate with serial number %s found" % (serial, ))
        raise pkidbbackends.PKIDBException(message="No certificate with serial number %s found" % (serial, ))

    else:
        backend.remove_certificate(serial)

def renew_certificate(opts, config, backend):
    """
    Renew a certificate identified by the serial number
    :param opts: options
    :param config: configuration
    :param backend: backend
    :return: None
    """

    validity_period = long(config["global"]["validity_period"])
    output = None

    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["renew"], longoptions["renew"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg, ))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg, ))

    for (opt, val) in optval:
        if opt in ("-p", "--period"):
            try:
                validity_period = float(val)
            except ValueError as error:
                __logger.error("Can't parse validity period option %s: %s" % (val, error.message))
                raise pkidbbackends.PKIDBException(message="Can't parse validity period option %s: %s"
                                                           % (val, error.message))

        elif opt in ("-o", "--output"):
            output = val
        else:
            __logger.error("Unknown option %s" % (opt, ))
            raise pkidbbackends.PKIDBException(message="Unknown option %s" % (opt, ))

    serial = None
    if len(trailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = trailing[0]

    serial = serial_to_number(serial)

    notbefore = time.time()
    notafter = notbefore + 86400. * validity_period

    notbefore = backend._unix_timestamp_to_asn1_time(notbefore)
    notafter = backend._unix_timestamp_to_asn1_time(notafter)

    ca_key = load_private_key(config, "ca_private_key", "ca_passphrase")

    newcert = backend.renew_certificate(serial, notbefore, notafter, ca_key)

    if not newcert:
        raise pkidbbackends.PKIDBException(message="Can't renew certificate with serial number %s" % (serial, ))

    pem_data = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, newcert)
    if output:
        try:
            fd = open(output, "w")
            fd.write(pem_data)
            fd.close()
        except IOError as error:
            __logger.error("Can't write to output file %s: %s" % (output, error.strerror))
            raise pkidbbackends.PKIDBException(message="Can't write to output file %s: %s" % (output, error.strerror))

    else:
        sys.stdout.write(pem_data)

    return None

def serial_to_number(serial):
    """
    Convert a string to the decimal value of serial number
    String can be a decimal number or hexadecimal (0x...)
    or hexadecimal separated by ":" (ca:fe:ba:be)
    :param serial: string containing serial number
    :return: decimal value of serial number string
    """
    re_serial_is_hex = re.compile("0x[0-9a-fA-F]+")

    # convert serial number to a number
    try:
        # check for 0x...
        if re_serial_is_hex.match(serial):
            serial = long(serial, 16)
        # it contains ":" we assume it is hexadecimal
        elif serial.find(":") >= 0:
            serial = serial.replace(":", "")
            serial = long(serial, 16)
        # assuming decimal value
        else:
            serial = long(serial)
    except ValueError as error:
        __logger.error("Can't convert serial number %s: %s" % (serial, error.message))
        raise pkidbbackends.PKIDBException(message="Can't convert serial number %s: %s" % (serial, error.message))

    return serial

def revoke_certificate(opts, config, backend):
    """
    Revoke a certificate identified by the serial number
    :param opts: options
    :param config: configurationd
    :param backend: backend
    :return: None
    """

    re_asn1_time_string = re.compile("^\d{14}Z$")
    force = False
    reason = "unspecified"
    rev_date = time.time()

    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["revoke"], longoptions["revoke"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg, ))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg, ))

    for (opt, val) in optval:
        if opt in ("-R", "--revocation-date"):
            # ASN1 GENERALIZEDTIME string?
            if re_asn1_time_string.match(val):
                # convert to UNIX timestamp
                rev_date = time.mktime(time.strptime(val, "%Y%m%d%H%M%SZ"))

            try:
                rev_date = float(val)
            except ValueError as error:
                __logger.error("Can't parse end time %s: %s" % (val, error.message))
                raise pkidbbackends.PKIDBException(message="Can't parse end time %s: %s" % (val, error.message))

        elif opt in ("-r", "--reason"):
            if val.lower() in backend._revocation_reason_map:
                reason = val.lower()
            else:
                __logger.error("%s is not a valid revocation reason" % (val, ))
                raise pkidbbackends.PKIDBException(message="%s is not a valid revocation reason" % (val, ))

        elif opt in ("-f", "--force"):
            force = True
        else:
            __logger.error("Unknown option %s" % (opt, ))
            raise pkidbbackends.PKIDBException(message="Error: Unknown option %s" % (opt, ))

    if len(trailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = trailing[0]

    serial = serial_to_number(serial)

    if not backend.get_certificate(serial) and not force:
        __logger.error("Certificate with serial number %s not found in database. If you want to revoke a certificate "
                       "by it's serial number that is not present in the database, use the force option." % (serial, ))
        raise pkidbbackends.PKIDBException(message="Certificate with serial number %s not found in database. "
                                                   "If you want to revoke a certificate by it's serial number that is "
                                                   "not present in the database, use the force option." % (serial, ))

    backend.revoke_certificate(serial, reason, rev_date, force=force)

def generate_certificate_revocation_list(opts, config, backend):
    """
    Generate certificate revocation list
    :param opts: options
    :param config: configurationd
    :param backend: backend
    :return: None
    """

    output = None

    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["gencrl"], longoptions["gencrl"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg, ))
        raise pkidbbackends.PKIDBException("Can't parse command line: %s" % (error.msg, ))

    for (opt, val) in optval:
        if opt in ("-o", "--output"):
            output = val
        else:
            __logger.error("Error: Unknown option %s" % (opt, ))
            raise pkidbbackends.PKIDBException("Unknown option %s" % (opt, ))

    # load CRL signing keys
    crl_pub_key = load_public_key(config, "crl_public_key")
    crl_priv_key = load_private_key(config, "crl_private_key", "crl_passphrase")

    crl = backend.generate_revocation_list()

    crl_period = None
    if "crl_validity_period" in config["global"]:
        crl_period = long(config["global"]["crl_validity_period"])

    crl_data = None

    # CRL.export() parameter digest is available in pyopenssl 0.15
    if OpenSSL.__version__ >= "0.15":

        crl_digest = None
        if "crl_digest" in config["global"]:
            crl_digest = config["global"]["crl_digest"]

            crl_data = crl.export(crl_pub_key, crl_priv_key, type=OpenSSL.crypto.FILETYPE_PEM,
                                  days=crl_period, digest=crl_digest)

    else:
        __logger.warning("Using an other digest for CRL signing than MD5 supported since version 0.15 of "
                         "pyOpenSSL (but this is %s). Falling back to MD5." % (OpenSSL.__version__, ))
        crl_data = crl.export(crl_pub_key, crl_priv_key, type=OpenSSL.crypto.FILETYPE_PEM,
                              days=crl_period)

    if output:
        try:
            fd = open(output, "w")
            fd.write(crl_data)
            fd.close()
        except IOError as error:
            __logger.error("Can't write CRL data to output file %s: %s" % (output, error.strerror))
            raise pkidbbackends.PKIDBException(message="Can't write CRL data to output file %s: %s"
                                                       % (output, error.strerror))
    else:
        sys.stdout.write(crl_data)

def sign_certificate(opts, config, backend):
    """
    Sign a certificate signing request.
    :param opts: array with options
    :param config: parsed configuration file
    :param backend: backend object
    :return: 0 on success or !=0 otherwise
    """

    output = None
    extensions = []
    input = None
    start = None
    valid_for = None
    templatedata = {"global": {}, "extension": [], }

    re_asn1_time_string = re.compile("^\d{14}Z$")
    re_oid = re.compile("[0-9\.]+")
    re_ca_flag = re.compile("CA:([A-Za-z]+)(.*)")

    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["sign"], longoptions["sign"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg, ))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg, ))

    for (opt, val) in optval:
        if opt in ("-E", "--extension"):
            ext = val.split(",", 4)
            if len(ext) != 5:
                __logger.error("Illegal number of fields for extension (expect:%u got %u)" %(4, len(ext)))
                raise pkidbbackends.PKIDBException(message="Illegal number of fields for extension (expect:%u got %u)"
                                                           % (4, len(ext)))

            name = None
            subject = None
            issuer = None
            data = None

            name = ext[0]
            if ext[1] in ("1", "True"):
                critical = True
            else:
                critical = False

            if ext[2] == '':
                subject = None
            else:
                subject = ext[2]

            if ext[3] == '':
                issuer = None
            else:
                issuer = ext[3]

            data = ext[4]

            # append new extension object
            extensions.append(OpenSSL.crypto.X509Extension(name, critical, data, subject=subject, issuer=issuer))
        elif opt in ("-S", "--san"):
            san = val
            critical = False
            if san.split(":", 1)[0].lower() == "critical":
                critical = True
                san = san.split(":", 1)[1]
            extensions.append(OpenSSL.crypto.X509Extension("subjectAltName", critical, san))
        elif opt in ("-K", "--extended-keyusage"):
            extusage = val
            critical = False
            if extusage.split(":", 1)[0].lower() == "critical":
                critical = True
                extusage = extusage.split(":", 1)[1]

            extusagelist = extusage.split(",")
            for eusage in extusagelist:
                if not eusage.strip().lower() in backend._extended_keyusage_list:
                    if not re_oid.match(eusage.strip()):
                        __logger.error("Invalid extended key usage %s" % (eusage, ))
                        raise pkidbbackends.PKIDBException("Invalid extended key usage %s" % (eusage, ))

            value = ",".join(extusagelist)
            extensions.append(OpenSSL.crypto.X509Extension("extendedKeyUsage", critical, value))

        elif opt in ("-k", "--keyusage"):
            keyusage = val
            critical = False
            if keyusage.split(":", 1)[0].lower() == "critical":
                critical = True
                keyusage = keyusage.split(":", 1)[1]

            # map usage list to bit values as defined in RFC 5280
            usagelist = keyusage.split(",")

            for usage in usagelist:
                if not usage.strip().lower() in backend._keyusage_list:
                    __logger.error("%s is not a valid key usage" % (usage, ))
                    raise pkidbbackends.PKIDBException("%s is not a valid key usage" % (usage, ))

            value = ",".join(usagelist)
            extensions.append(OpenSSL.crypto.X509Extension("keyUsage", critical, value))
        elif opt in ("-b", "--basic-constraint"):
            basic = val
            critical = False
            if basic.split(":", 1)[0].lower() == "critical":
                critical = True
                basic = basic.split(":", 1)[1]

            # ASN1 expects boolean as FALSE or TRUE (not False, True, true, ...)
            # so for the sake of sanity check and convert flag to uppercase
            if re_ca_flag.match(basic):
                flag = re_ca_flag.match(basic).groups()[0]
                remainder = re_ca_flag.match(basic).groups()[1]
                if flag.lower() == "true":
                    flag = "TRUE"
                elif flag.lower() == "false":
                    flag = "FALSE"
                else:
                    __logger.error("%s is not a valid boolean flag" % (flag, ))
                    raise pkidbbackends.PKIDBException(message="%s is not a valid boolean flag" % (flag, ))

                # put them together again
                basic = "CA:%s%s" % (flag, remainder)

            extensions.append(OpenSSL.crypto.X509Extension("basicConstraints", critical, basic))

        elif opt in ("-v", "--valid-for"):
            valid_for = val

            # convert to integer
            try:
                valid_for = int(valid_for)
            except ValueError as error:
                __logger.error("Can't convert argument to an integer %s: %s" % (valid_for, error.message))
                raise pkidbbackends.PKIDBException(message="Can't convert argument to an integer %s: %s" %
                                                           (valid_for, error.message))

        elif opt in ("-s", "--start-in"):
            start = val

            try:
                start = float(start)
            except ValueError as error:
                __logger.error("Can't convert argument to an integer %s: %s" % (start, error.message))
                raise pkidbbackends.PKIDBException(message="Can't convert argument to an integer %s: %s" %
                                                           (valid_for, error.message))

        elif opt in ("-t", "--template"):
            parsed = parseoptions(val)
            for key in parsed.keys():
                if key == "global":
                    templatedata["global"] = parsed["global"]
                else:
                    (ext, name) = key.split(":", 1)
                    if ext == "extension":
                        critical = False
                        if "critical" in parsed[key]:
                            critical = True

                        data = ''
                        if "data" in parsed[key]:
                            data = parsed[key]["data"]
                        elif "data:base64" in parsed[key]:
                            data = base64.b64decode(parsed[key]["data:base64"])
                        else:
                            __logger.error("No data found in extension section %s" % (key, ))
                            raise pkidbbackends.PKIDBException("No data found in extension section %s" % (key, ))

                        subject = None
                        if "subject" in parsed[key]:
                            subject = parsed[key]["subject"]

                        issuer = None
                        if "issuer" in parsed[key]:
                            issuer = parsed[key]["issued"]

                        extdata = {
                            "name": name,
                            "critical": critical,
                            "data": data,
                            "subject": subject,
                            "issuer": issuer,
                        }
                        templatedata["extension"].append(extdata)

        elif opt in ("-o", "--output"):
            output = val

        else:
            __logger.error("Unknown option %s" % (opt, ))
            raise pkidbbackends.PKIDBException(message="Error: Unknown option %s" % (opt, ))

    # data from template override global settings
    validity_period = int(config["global"]["validity_period"])
    digest = None
    if templatedata:
        if "validity_period" in templatedata["global"]:
            validity_period = int(templatedata["global"]["validity_period"])
        if "digest" in templatedata["global"]:
            digest = templatedata["global"]["digest"]

    # add extensions from template
    for ext in templatedata["extension"]:
        extensions.append(OpenSSL.crypto.X509Extension(ext["name"], ext["critical"], ext["data"], ext["subject"],
                                                       ext["issuer"]))
    if not start:
        start = 0

    if not valid_for:
        valid_for = validity_period

    if len(trailing) == 0:
        input = sys.stdin

    elif len(trailing) == 1:
        try:
            input = open(trailing[0], "r")
        except IOError as error:
            __logger.error("Can't open %s for reading: %s" % (trailing[0], error.strerror))
            raise pkidbbackends.PKIDBException(message="Can't open %s for reading: %s" % (trailing[0], error.strerror))

    else:
        __logger.error("Too much arguments. Expect zero or one, got %u instead" % (len(trailing),))
        raise pkidbbackends.PKIDBException(message="Too much arguments. Expect zero or one, got %u instead"
                                                   % (len(trailing),))

    # csr read data from input
    try:
        data = input.read()
    except IOError as error:
        __logger.error("Read from %s failed: %s" % (input.name, error.strerror))
        raise pkidbbackends.PKIDBException(message="Error: Read from %s failed: %s" % (input.name, error.strerror))

    # close non stdin input
    if input != sys.stdin:
        input.close()

    # assuming PEM input
    csr = OpenSSL.crypto.load_certificate_request(OpenSSL.crypto.FILETYPE_PEM, data)

    # X509Req.get_extensions() is available in pyopenssl 0.15
    if OpenSSL.__version__ >= "0.15":
        # FIXME: Handle get_extensions()
        pass

    # load private CA key
    ca_priv_key = load_private_key(config, "ca_private_key", "ca_passphrase")
    if not ca_priv_key:
        __logger.error("Failed to load CA private key (Wrong password ?)")
        raise pkidbbackends.PKIDBException("Error: Failed to load CA private key (Wrong password?)")

    ca_pub_key = load_public_key(config, "ca_public_key")
    if not ca_pub_key:
        __logger.error("Failed to load CA public key")
        raise pkidbbackends.PKIDBException(message="Failed to load CA public key")

    # adjust start and and time

    # We do not pass the issuer of the CA, because only for root CA is issuer == subject
    # Intermediate CAs will contain their issuing CA as issuer
    newcert = backend.sign_request(csr, start, valid_for, ca_priv_key, ca_pub_key.get_subject(), extensions, digest)

    newcert_pem = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, newcert)

    if output:
        try:
            fd = open(output, "w")
            fd.write(newcert_pem)
            fd.close()
        except IOError as error:
            __logger.error("Can't open output file %s for writing: %s" % (output, error.strerror))
            raise pkidbbackends.PKIDBException(message="Error: Can't open output file %s for writing: %s"
                                                       % (output, error.strerror))

    else:
        sys.stdout.write(newcert_pem)

def load_public_key(config, keyname):
    """
    Loads issuer from CA public key
    :param config: configuration
    :param keyname: name of public key in [global] section
    :return: X509 object representing CA public key
    """

    result = None
    try:
        fd = open(config["global"][keyname], "r")
        data = fd.read()
        fd.close()
    except IOError as error:
        __logger.error("Can't read public key %s: %s" % (config["global"][keyname], error.strerror, ))
        raise pkidbbackends.PKIDBException(message="Can't read public key %s: %s"
                                                   % (config["global"][keyname], error.strerror, ))

    try:
        pubkey = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, data)
    except OpenSSL.crypto.Error as error:
        __logger.error("Invalid public key: %s" % (error.message, ))
        raise pkidbbackends.PKIDBException(message="Error: Invalid public key: %s" % (error.message, ))

    return pubkey

def load_private_key(config, keyname, passphrase):
    """
    Load CA keyfile
    :param config: configuration
    :param keyname: name of private key in [global] section
    :param passphrase: name of passphrase variable in [global] section
    :return: private CA key as PKey object or None
    """

    result = None
    key_passphrase = config["global"][passphrase]

    try:
        fd = open(config["global"][keyname], "r")
        data = fd.read()
        fd.close()
    except IOError as error:
        __logger.error("Can't read private key %s: %s" % (config["global"][keyname], error.strerror, ))
        raise pkidbbackends.PKIDBException("Can't read private key %s: %s"
                                           % (config["global"][keyname], error.strerror, ))

    try:
        result = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, data, passphrase=key_passphrase)
    except OpenSSL.crypto.Error as error:
        __logger.error("Can't load private key. Wrong password ?")
        raise pkidbbackends.PKIDBException(message="Can't load private key. Wrong password?")

    return result

def import_certificate(opts, config, backend):
    """
    Import a certificate (PEM) into the backend
    :param opts: options for import
    :param config: parsed configuration file
    :param backend: backend object
    :return: 0 on success, != 0 otherwise
    """

    re_asn1_time_string = re.compile("^\d{14}Z$")
    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["import"], longoptions["import"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg, ))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg, ))

    csr = None
    revoked = None
    autorenewable = False
    autorenew_period = float(config["global"]["validity_period"])
    auto_renew_start_period = float(config["global"]["auto_renew_start_period"])

    for (opt, val) in optval:
        if opt in ("-c", "--csr"):
            try:
                fd = open(val, "r")
                csrdata = fd.read()
                fd.close()
            except IOError as error:
                __logger.error("Can't read certificate signing request from %s: %s" % (val, error.strerror))
                raise pkidbbackends.PKIDBException(message="Can't read certificate signing request from %s: %s"
                                                           % (val, error.strerror))

            csr = OpenSSL.crypto.load_certificate_request(OpenSSL.crypto.FILETYPE_PEM, csrdata)

        elif opt in ("-r", "--revoked"):
            # format: <reason>,<revocation_stamp>
            (reason, revtime) = val.split(',')

            # ASN1 GENERALIZEDTIME string?
            if re_asn1_time_string.match(revtime):
                # convert to UNIX timestamp
                revtime = time.mktime(time.strptime(revtime, "%Y%m%d%H%M%SZ"))

            # check timestamp
            try:
                revtime = float(revtime)
            except ValueError as error:
                __logger.error("Illegal timestamp %s" % (revtime, ))
                raise pkidbbackends.PKIDBException(message="Illegal timestamp %s" % (revtime, ))

            # treat no reason as unspecified
            if reason == '':
                reason = "unspecified"

            # check reason string
            if reason.lower() in backend._revocation_reason_map:
                revoked = (backend._revocation_reason_map[reason.lower()], revtime)

            elif opt in ("-a", "--auto-renew"):
                autorenewable = True

        elif opt in ("-p", "--period"):
            try:
                autorenew_period = float(val)
            except ValueError as error:
                __logger.error("Can't parse validity period option %s: %s" % (val, error.message))
                raise pkidbbackends.PKIDBException(message="Can't parse validity period option %s: %s"
                                                           % (val, error.message))

        elif opt in ("-d", "--delta"):
            try:
                auto_renew_start_period = float(val)
            except ValueError as error:
                __logger.error("Can't parse delta period option %s: %s" % (val, error.message))
                raise pkidbbackends.PKIDBException(message="Can't parse delta period option %s: %s"
                                                           % (val, error.message))

            else:
                __logger.error("Unknown revocation reason %s" % (reason, ))
                raise pkidbbackends.PKIDBException(message="Unknown revocation reason %s" % (reason, ))

    input = None

    # discard autorenew_period if imported certificate is not marked as autorenewable
    if not autorenewable:
        autorenew_period = None
        auto_renew_start_period = None

    if len(trailing) == 0:
        input = sys.stdin

    elif len(trailing) == 1:
        try:
            input = open(trailing[0], "r")
        except IOError as error:
            __logger.error("Can't open %s for reading: %s" % (trailing[0], error.strerror))
            raise pkidbbackends.PKIDBException(message="Can't open %s for reading: %s" % (trailing[0], error.strerror))

    else:
        __logger.error("Too much arguments. Expect zero or one, got %u instead" % (len(trailing), ))
        raise pkidbbackends.PKIDBException(message="Too much arguments. Expect zero or one, got %u instead"
                                                   % (len(trailing), ))

    try:
        data = input.read()
    except IOError as error:
        __logger.error("Read from %s failed: %s" % (input.name, error.strerror))
        raise pkidbbackends.PKIDBException(message="Read from %s failed: %s" % (input.name, error.strerror))

    # close non stdin input
    if input != sys.stdin:
        input.close()

    # assuming PEM input
    cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, data)
    backend.store_certificate(cert, csr, revoked, autorenew=autorenewable, validity_period=auto_renew_start_period)

def housekeeping(opts, config, backend):
    """
    Check certificates in the backend for expiration, auto renew autorenewable certificates.
    :param opts: options for import
    :param config: parsed configuration file
    :param backend: backend object
    :return: None
    """
    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["housekeeping"], longoptions["housekeeping"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg, ))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg, ))

    autorenew = False
    autorenew_period = None

    for (opt, val) in optval:
        if opt in ("-a", "--auto-renew"):
            autorenew = True
        elif opt in ("-p", "--period"):
            try:
                autorenew_period = float(val)
            except ValueError as error:
                __logger.error("Can't parse autorenew period option %s: %s" % (val, error.message))
                raise pkidbbackends.PKIDBException(message="Can't parse autorenew period option %s: %s"
                                                           % (val, error.message))

    if not autorenew:
        autorenew_period = None

    backend.housekeeping(autorenew=autorenew, validity_period=autorenew_period)

    return None

def remove_certificate(opts, config, backend):
    """
    Remove certificate identified by the serial number.
    :param opts: options for import
    :param config: parsed configuration file
    :param backend: backend object
    :return: None
    """
    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["remove"], longoptions["remove"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg, ))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg, ))

    for (opt, val) in optval:
        pass

    serial = None
    if len(trailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = trailing[0]

    serial = serial_to_number(serial)

    stats = backend.remove_certificate(serial)

def print_statistics(opts, config, backend):
    """
    Print statistics of certificates in the backend database.
    :param opts: options for import
    :param config: parsed configuration file
    :param backend: backend object
    :return: None
    """
    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["statistics"], longoptions["statistics"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg, ))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg, ))

    for (opt, val) in optval:
        pass

    stats = backend.get_statistics()

    for stat_type in stats:
        for key in stats[stat_type]:
            print("%s:%s:%u" % (stat_type, key, stats[stat_type][key]))

    return None

def _get_loglevel(string):
    """
    Returns value of loglevel for logging from string
    :param string: string
    :return: numeric loglevel
    """
    if string.lower() == "debug":
        return logging.DEBUG
    elif string.lower() == "info":
        return logging.INFO
    elif string.lower() == "warning":
        return logging.WARNING
    elif string.lower() == "warn":
        return logging.WARN
    elif string.lower() == "error":
        return logging.ERROR
    elif string.lower() == "critical":
        return logging.CRITICAL
    else:
        sys.stderr.write("Error: Unknown log level %s\n" % (string, ))
        sys.exit(2)

def setup_logging(options):
    """
    Setup logging based on the configuration setting
    :param options: parsed config file
    :return: None
    """
    global __logger

    name = os.path.basename(sys.argv[0])
    logformat = logging.Formatter(name + " %(name)s:%(lineno)d %(levelname)s: %(message)s")

    re_logging=re.compile("(\w+),(\w+):(.*)$")
    if "logging" in options:
        __logger = logging.getLogger("__main__")
        __logger.setLevel(logging.INFO)

        for log in options["logging"]:
            if re_logging.match(options["logging"][log]):
                (level, logtype, logoptions) = re_logging.match(options["logging"][log]).groups()

                if logtype.lower() == "file":
                    handler = logging.FileHandler(logoptions)
                    handler.setLevel(_get_loglevel(level))
                    flogformat = logging.Formatter("%(asctime)s " + name +
                                                  " %(name)s:%(lineno)d %(levelname)s: %(message)s",
                                                  datefmt='%d %b %Y %H:%M:%S')
                    handler.setFormatter(flogformat)
                    __logger.addHandler(handler)
                elif logtype.lower() == "syslog":
                    handler = logging.handlers.SysLogHandler(address="/dev/log", facility=logoptions.lower())
                    handler.setLevel(_get_loglevel(level))
                    handler.setFormatter(logformat)
                    __logger.addHandler(handler)
                else:
                    sys.stderr.write("Error: Unknown logging mechanism %s\n" % (logtype, ))
    else:
        # set default logging
        # initialize logging subsystem
        address = '/dev/log'
        handler = logging.handlers.SysLogHandler(address=address)
        handler.setLevel(logging.INFO)
        handler.setFormatter(logformat)

        __logger.addHandler(handler)

def add_dummy(opts, config, backend):
    """
    Add dummy certificate identified by it's serial number.
    :param opts: options for import
    :param config: parsed configuration file
    :param backend: backend object
    :return: None
    """

    notbefore = None
    notafter = None
    subject = None
    serial = None

    re_asn1_time_string = re.compile("^\d{14}Z$")

    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["add-dummy"], longoptions["add-dummy"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg))

    for (opt, val) in optval:
        if opt in ("-s", "--start"):
            # ASN1 GENERALIZEDTIME string?
            if re_asn1_time_string.match(val):
                # convert to UNIX timestamp
                notbefore = time.mktime(time.strptime(val, "%Y%m%d%H%M%SZ"))

            try:
                notbefore = float(val)
            except ValueError as error:
                __logger.error("Can't parse start time %s: %s" % (val, error.message))
                raise pkidbbackends.PKIDBException(message="Can't parse start time %s: %s" % (val, error.message))

        elif opt in ("-e", "--end"):
            # ASN1 GENERALIZEDTIME string?
            if re_asn1_time_string.match(val):
                # convert to UNIX timestamp
                notafter = time.mktime(time.strptime(val, "%Y%m%d%H%M%SZ"))

            try:
                notafter = float(val)
            except ValueError as error:
                __logger.error("Can't parse end time %s: %s" % (val, error.message))
                raise pkidbbackends.PKIDBException(message="Can't parse end time %s: %s" % (val, error.message))

        elif opt in ("-S", "--subject"):
            subject = val

    if len(trailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = trailing[0]

    serial = serial_to_number(serial)

    if not subject:
        subject = "Placeholder, set for imported certificate with serial number %s" % (str(serial), )

    backend.insert_empty_cert_data(serial, subject, notbefore, notafter)

def search_certificate(opts, config, backend):
    """
    Search database for subject.
    :param opts: options for import
    :param config: parsed configuration file
    :param backend: backend object
    :return: None
    """
    searchstring = None

    try:
        (optval, trailing) = getopt.getopt(opts, shortoptions["search"], longoptions["search"])
    except getopt.GetoptError as error:
        __logger.error("Can't parse command line: %s" % (error.msg))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (error.msg))

    for (opt, val) in optval:
        pass

    if len(trailing) == 0:
        searchstring = sys.stdin.read()
    else:
        searchstring = trailing[0]

    if searchstring and len(searchstring) > 0:
        result = backend.search_certificate(searchstring)

        for res in result:
            sys.stdout.write("%s\n" % (long(res), ))

def version():
    """
    Shows version.
    :return: None
    """
    print("""python-pkidb version %s
Copyright (C) 2015 - 2016 by Andreas Maus <maus@ypbind.de>
This program comes with ABSOLUTELY NO WARRANTY.

python-pkidb is distributed under the Terms of the GNU General
Public License Version 3. (http://www.gnu.org/copyleft/gpl.html)

""" % (__version__, ))

if __name__ == "__main__":
    failed = False

    # parse commandline options
    try:
        (optval, trailing) = getopt.getopt(sys.argv[1:], shortoptions["main"], longoptions["main"])
    except getopt.GetoptError as error:
        sys.stderr.write("Error: Can't parse command line: %s\n" % (error.msg, ))
        sys.exit(1)

    for (opt, val) in optval:
        if opt in ("-h", "--help"):
            usage()
            sys.exit(0)
        elif opt in ("-c", "--config"):
            configfile = val
        elif opt in ("-V", "--version"):
            version()
            sys.exit(0)
        else:
            sys.stderr.write("Error: Unknown option %s" % (opt,))
            sys.exit(1)

    if not os.access(configfile, os.R_OK):
        sys.stderr.write("Error: Can't open configuration file %s for reading\n" % (configfile, ))
        sys.exit(1)

    options = parseoptions(configfile)
    setup_logging(options)
    # FIXME: Validate options

    backend = None

    # create backend object
    if "backend" in options["global"]:
        if options["global"]["backend"] == "pgsql":
            import pkidbbackends.pgsql
            backend = pkidbbackends.pgsql.PostgreSQL(options)
        elif options["global"]["backend"] == "sqlite3":
            import pkidbbackends.sqlite
            backend = pkidbbackends.sqlite.SQLite(options)
        elif options["global"]["backend"] == "mysql":
            import pkidbbackends.mysql
            backend = pkidbbackends.mysql.MySQL(options)
        else:
            __logger.error("Unknown backend type %s" % (options["global"]["backend"], ))
            sys.exit(1)

    if len(trailing) == 0:
        sys.stderr.write("Error: Missing command\n")
        __logger.error("Missing command")
        usage()
        sys.exit(1)

    command = trailing[0]
    start = time.time()

    try:
        if command == "sign":
            sign_certificate(trailing[1:], options, backend)
        elif command == "help":
            usage()
            sys.exit(0)
        elif command == "import":
            import_certificate(trailing[1:], options, backend)
        elif command == "housekeeping":
            housekeeping(trailing[1:], options, backend)
        elif command == "statistics":
            print_statistics(trailing[1:], options, backend)
        elif command == "gencrl":
            generate_certificate_revocation_list(trailing[1:], options, backend)
        elif command == "revoke":
            revoke_certificate(trailing[1:], options, backend)
        elif command == "renew":
            renew_certificate(trailing[1:], options, backend)
        elif command == "export":
            export_certificate(trailing[1:], options, backend)
        elif command == "backup":
            backup_database(trailing[1:], options, backend)
        elif command == "list":
            list_certificates(trailing[1:], options, backend)
        elif command == "restore":
            restore_database(trailing[1:], options, backend)
        elif command == "delete":
            delete_certificate(trailing[1:], options, backend)
        elif command == "show":
            show_certificate(trailing[1:], options, backend)
        elif command == "set":
            set_certificate_metadata(trailing[1:], options, backend)
        elif command == "healthcheck":
            healthcheck(trailing[1:], options, backend)
        elif command == "add-dummy":
            add_dummy(trailing[1:], options, backend)
        elif command == "search":
            search_certificate(trailing[1:], options, backend)
        else:
            sys.stderr.write("Error: Unknown command %s\n" % (command, ))
            __logger.error("Unknown command %s" % (command, ))
            usage()
            sys.exit(1)
    except pkidbbackends.PKIDBException as pkidberror:
        sys.stderr.write("Error: Command %s failed: %s\n" % (command, pkidberror.message))
        __logger.error("Command %s failed: %s" % (command, pkidberror.message))
        failed = True

    stop = time.time()
    __logger.info("Command %s finished after %f seconds" % (command, (stop - start)))
    if failed:
        sys.exit(1)
    else:
        sys.exit(0)
