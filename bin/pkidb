#!/usr/bin/env python -W ignore::DeprecationWarning
#
# This version is
#   Copyright (C) 2015 Andreas Maus
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program. If not, see <https://www.gnu.org/licenses/>.
#


import pkidbbackends
import base64
import getopt
import json
import logging
import logging.handlers
import math
import os
import re
import sys
import time
import OpenSSL

# default configuration file
configfile = "/etc/pkidb/config.ini"

__version__ = "0.8.14.1"

shortoptions = {
    "main": "c:hVs:",
    "sign": "b:o:s:v:E:S:k:K:t:n",
    "import": "c:r:a:p:d:",
    "housekeeping": "ap:",
    "statistics": "",
    "gencrl": "o:",
    "revoke": "fr:R:",
    "renew": "o:p:",
    "export": "o:",
    "remove": "",
    "backup": "o:",
    "list": "eiho:rtv",
    "restore": "",
    "delete": "",
    "show": "o:",
    "set": "ac:AP:V:",
    "healthcheck": "f",
    "add-dummy": "s:e:S:",
    "search": "",
}

longoptions = {
    "main": ["config=", "help", "version", "site="],
    "sign": ["output=", "start-in=", "valid-for=", "extension=", "san=", "keyusage=", "extended-keyusage=",
             "basic-constraint=", "template=", "no-register"],
    "import": ["csr=", "revoked=", "auto-renew", "period=", "delta="],
    "housekeeping": ["auto-renew", "period="],
    "statistics": [],
    "gencrl": ["output="],
    "revoke": ["force", "reason=", "revocation-date="],
    "renew": ["output=", "period="],
    "export": ["output="],
    "remove": [],
    "backup": ["output="],
    "list": ["expired", "hex", "invalid", "output=", "revoked", "temporary", "valid"],
    "restore": [],
    "delete": [],
    "show": ["output="],
    "set": ["auto-renew", "csr=", "no-auto-renew", "auto-renew-start-period=", "auto-renew-validity-period="],
    "healthcheck": ["fix"],
    "add-dummy": ["start=", "end=", "subject="],
    "search": [],
}

__logger = None

# Python 3 renamed ConfigParser to configparser
if sys.version_info[0] < 3:
    # noinspection PyPep8Naming
    import ConfigParser as configparser
else:
    import configparser


# map environment variables to configuration
environment_to_configuration = {
    "PKIDB_GLOBAL_BACKEND": {"section": "global", "key": "backend"},
    "PKIDB_GLOBAL_CA_PUBLIC_KEY": {"section": "global", "key": "ca_public_key"},
    "PKIDB_GLOBAL_CA_CERTIFICATE": {"section": "global", "key": "ca_certificate"},
    "PKIDB_GLOBAL_CA_PRIVATE_KEY": {"section": "global", "key": "ca_private_key"},
    "PKIDB_GLOBAL_CA_PASSPHRASE": {"section": "global", "key": "ca_passphrase"},
    "PKIDB_GLOBAL_DIGEST": {"section": "global", "key": "digest"},
    "PKIDB_GLOBAL_SERIAL_NUMBER": {"section": "global", "key": "serial_number"},
    "PKIDB_GLOBAL_VALIDITY_PERIOD": {"section": "global", "key": "validity_period"},
    "PKIDB_GLOBAL_AUTO_RENEW_START_PERIOD": {"section": "global", "key": "auto_renew_start_period"},
    "PKIDB_GLOBAL_CRL_PUBLIC_KEY": {"section": "global", "key": "crl_public_key"},
    "PKIDB_GLOBAL_CRL_CERTIFICATE": {"section": "global", "key": "crl_certificate"},
    "PKIDB_GLOBAL_CRL_PRIVATE_KEY": {"section": "global", "key": "crl_private_key"},
    "PKIDB_GLOBAL_CRL_PASSPHRASE": {"section": "global", "key": "crl_passphrase"},
    "PKIDB_GLOBAL_CRL_VALIDITY_PERIOD": {"section": "global", "key": "crl_validity_period"},
    "PKIDB_GLOBAL_CRL_DIGEST": {"section": "global", "key": "crl_digest"},
    "PKIDB_GLOBAL_LIST_AS_HEX": {"section": "global", "key": "list_as_hex"},
    "PKIDB_PGSQL_HOST": {"section": "pgsql", "key": "host"},
    "PKIDB_PGSQL_PORT": {"section": "pgsql", "key": "port"},
    "PKIDB_PGSQL_DATABASE": {"section": "pgsql", "key": "database"},
    "PKIDB_PGSQL_USER": {"section": "pgsql", "key": "user"},
    "PKIDB_PGSQL_PASSPHRASE": {"section": "pgsql", "key": "passphrase"},
    "PKIDB_PGSQL_SSLMODE": {"section": "pgsql", "key": "sslmode"},
    "PKIDB_PGSQL_SSLCACERT": {"section": "pgsql", "key": "sslcacert"},
    "PKIDB_PGSQL_SSLCERT": {"section": "pgsql", "key": "sslcert"},
    "PKIDB_PGSQL_SSLKEY": {"section": "pgsql", "key": "sslkey"},
    "PKIDB_MYSQL_HOST": {"section": "mysql", "key": "host"},
    "PKIDB_MYSQL_PORT": {"section": "mysql", "key": "port"},
    "PKIDB_MYSQL_DATABASE": {"section": "mysql", "key": "database"},
    "PKIDB_MYSQL_USER": {"section": "mysql", "key": "user"},
    "PKIDB_MYSQL_PASSPHRASE": {"section": "mysql", "key": "passphrase"},
    "PKIDB_MYSQL_SSLCACERT": {"section": "mysql", "key": "sslcacert"},
    "PKIDB_MYSQL_SSLCERT": {"section": "mysql", "key": "sslcert"},
    "PKIDB_MYSQL_SSLKEY": {"section": "mysql", "key": "sslkey"},
    "PKIDB_SQLITE3_DATABASE": {"section": "sqlite3", "key": "database"},
}


def mapconfigsections(config, section):
    """
    helper function to map ini sections and values
    :param config:  ConfigParser object
    :param section: section to parse
    :return:
    """
    resdict = {}
    cfgoptions = config.options(section)

    for option in cfgoptions:
        try:
            resdict[option] = config.get(section, option)
            if resdict[option] == -1:
                # skip option, remove from dictionary
                resdict.pop(option)
        except configparser.Error as cfgerror:
            sys.stderr.write("Error: Error parsing ini file: %s\n" % (cfgerror.message,))
            return None
    return resdict


def parseoptions(optfile):
    """
    Parses an "ini style" option file, returns result
    as dictionary
    :param optfile: optionfile to parse
    :return: parsed options
    """
    result = {}
    config = configparser.ConfigParser()
    config.read(optfile)
    # loop over sections
    try:
        for section in config.sections():
            result[section] = mapconfigsections(config, section)
    except configparser.Error as cfgerror:
        sys.stderr.write("Error: Can't parse configuration file %s: %s\n" % (optfile, cfgerror.message))
        result = None
    return result


def usage():
    version()

    print("""Usage: %s [-c <cfg>|--config=<cfg>] [-h|--help] <command> [<commandoptions>]

  -V                                        Shows version.
  --version

  -c <cfg>                                  Use configuration file instead of the default
  --config=<cfg>                            Default: %s

  -s <site>                                 Use configuration for <site>
  --site=<site>                             Default: Use global configuration or default site (if set and not empty)

  -h                                        This text
  --help

  Commands:

   add-dummy                                Add a dummy certificate identified by the serial number.
                                            If the serial number is not given on the command line it will be
                                            read from standard input.
                                            This can be used if the certificate has been issued but the certificate
                                            file is not present (e.g. during a migration) but the serial number
                                            and optionally the start date, end date or subject is known.

     -S <subject>                           Certificate subject.
     --subject=<subject>

     -s <start>                             Start of the certificates validity period.
     --start=<start>                        <start> is the UNIX epoch of the revocation or ASN1 GERNERALIZEDTIME
                                            string in the format YYYYMMDDhhmmssZ

     -e <end>                               End of the certificates validity period.
     --end=<end>                            <end> is the UNIX epoch of the revocation or ASN1 GERNERALIZEDTIME
                                            string in the format YYYYMMDDhhmmssZ

   backup                                   Dumps the content of the backend database in JSON format.
                                            This can be used to backup the PKI database and is the only
                                            supported way to migrate between different backend types.
                                            If no output file (option -o) has been given it will be written
                                            to standard output.

     -o <output>                            Write database dump to <output> instead of standard out.
     --output=<output>

   delete                                   Deletes a certificate identified by the serial number.
                                            If the serial number is not given on the command line it will be
                                            read from standard input.

   export                                   Dumps base64 encoded X509 data of a certificate (aka PEM format).
                                            The serial number of the certificate must be given.
                                            If not given it will be read from the standard input.
                                            The certificate will be written to standard output or to a file if
                                            the -o option is used.

     -o <output>                            Write certificate to <output> instead of standard out.
     --output=<output>

   gencrl                                   Generate certificate revocation list containing information about revoked
                                            certificates. The certificate revocation list will be written to standard
                                            output or to a file if -o is used.

     -o <output>                            Write revocation list to <output> instead of standard output.
     --output=<output>

   healthcheck                              Verify integrity of the stored certifiate data.

   -f                                       Fix errors. Stored data will be replaced with data from the certifiate
   --fix                                    stored in the database.

   housekeeping                             General "housekeeping". Checking all certificates in the database
                                            for expiration, renew auto renewable certificates (if option -a is used).
                                            This should be run at regular intervals.

     -a                                     Renew auto renawable certificates that will expire.
     --auto-renew

     -p <period>                            New validity period for auto renewed certificate.
     --period=<period>                      Default is the value given on import that has been stored in the backend.

   import                                   Import a certificate. If a file name is given it will be read
                                            from the file, otherwise it will be read from standard input.

     -a                                     Mark certificate as autorenwable.
     --auto-renew                           The "housekeeping" command will take care of this

     -c <csr>                               Certificate signing request used for certificate
     --csr=<csr>                            creation. Optional.

     -d <delta_period>                      For auto renewable certificates the auto renew process starts if the time
     --delta=<delta_period>                 til expiration is less than <delta_period> days.

     -p <period>                            New validity period for auto renewed certificate.
     --period=<period>                      Default is the value given in the configuration file as validity_period.

     -r <reason>,<time>                     Mark certificate as revoked. Optional.
     --revoked=<reason>,<time>              <time> is the UNIX epoch of the revocation or ASN1 GERNERALIZEDTIME
                                            string in the format YYYYMMDDhhmmssZ
                                            <reason> can be one of:
                                            unspecified, keyCompromise, CACompromise, affiliationChanged,
                                            superseded, cessationOfOperation, certificateHold, privilegeWithdrawn,
                                            removeFromCRL, aACompromise

   list                                     List serial numbers of certificates.
                                            The list will be written to standard out if the option -o is not used.

     -e                                     List serial numbers of expired certificates.
     --expired

     -i                                     List serial numbers of invalid certificates.
     --invalid                              Certficates are considered invalid if their notBefore time is in the future.

     -h                                     Print serial number as hexadecimal number.
     --hex

     -o <output>                            Write serial numbers of listed certificate to <output> instead to standard
     --output=<output>                      output.

     -r                                     List serial numbers of revoked certificates.
     --revoked

     -t                                     List "certificates" marked as temporary,
     --temporary                            Temporary certficates are dummy settings used to "lock" serial numbers
                                            during signing of a certificate signing request.

     -v                                     List serial numbers of valid certificates.
     --valid                                A certificates is considered valid if it is not temporary, not revoked,
                                            the validity period (notBefore .. notAfter) has started and the
                                            certificates is not expired.

   renew                                    Renew a cerificate. The serial number of the certificate must be given.
                                            If not given it will be read from the standard input.
                                            The new certificate will be written to standard output or to a file if
                                            the -o option is used.

     -o <output>                            Write new certificate to <output> instead of standard out
     --output=<output>

     -p <period>                            New validity period for renewed certificate.
     --period=<period>                      Default <validity_period> from configuration file.

   restore                                  Restores database from a JSON file generated with the backup command.
                                            If the filename of the input data is given on the command line it
                                            will be read, otherwise input will be read from standard input

   revoke                                   Revoke a certificate. Serial number of the certificate to revoke must
                                            be used. If not given on the command line it will be read from
                                            stdin.

     -f                                     Revoke certificate by it's serial number event it is not present in the
     --force                                database. A dummy entry will be inserted in the database and marked as
                                            revoked.

     -r <reason>                            Set revocation reason for certificate.
     --reason=<reason>                      <reason> can be one of:
                                            unspecified, keyCompromise, CACompromise, affiliationChanged,
                                            superseded, cessationOfOperation, certificateHold, privilegeWithdrawn,
                                            removeFromCRL, aACompromise
                                            If no reasen is given, the default "unspecified" is used.

     -R <date>                              Set revocation date for certificate.
     --revocation-date=<date>               <revdate> is the UNIX epoch of the revocation or ASN1 GERNERALIZEDTIME
                                            string in the format YYYYMMDDhhmmssZ.
                                            If not given, the current date will be used.

   search                                   Search certificate subject for a given string. Search string can be given
                                            on the command line. If omitted it will be read from standard input.
                                            SQL wildcards like %% can be used. The serial numbers matching the search
                                            will be printed to standard output.

   set                                      Modify meta data of a certificate identified by the serial number.
                                            The serial number of the certificate must be given on the command line or
                                            will be read from the standard input.

     -A                                     Mark a certificate as auto renewable.
     --auto-renew

     -P <period>                            Set auto renew start period in days. If there are less than <period> days
     --auto-renew-start-period=<period>     left until certificate expiration it will be renewed. The "housekeeping"
                                            command will renew the certificate.

     -V                                     Renew the certificate for <period> days. If not specified the setting
     --auto-renew-validity-period=<period>  from the configuration file will be used.

     -a                                     Remove auto renewable flag from certificate meta data.
     --no-auto-renew

     -c <signing_request>                   Set certificate signing request.
     --csr=<signing_request>

   show                                     Shows information of a certificate identified by the serial number.
                                            The serial number of the certificate must be given on the command line or
                                            will be read from the standard input.
                                            The certificate information will be written to standard output or to a
                                            file if the -o option is used.

     -o <output>                            Write new certificate information to <output> instead of standard output.
     --output=<output>

   sign                                     Sign a certificate signing request. If a file name is given it will be
                                            read, otherwise it will be read from stdin. Output will be written to
                                            stdout or to a file if -o option is used.

     -E <extdata>                           X509 extension. Can be repeated for multiple extensions.
     --extension=<extdata>                  Parameter <extdata> is a comma separated list of:
                                            <name> - Name of the X509 extension
                                            <critical> - Critical flag. 0: False, 1: True
                                            <subject> - Subject, is usually empty
                                            <issuer> - Issuer, is usually empty
                                            <data> - data of the extension

     -K [critical:]:<flags>                 Comma separated list of extended key usage bits.
     --extended-keyusage=[critical:]<flags> Prefix critical: can be used to set the critical flag.
                                            Additionally dotted numeric OID are allowed too, e.g. 1.2.3.4.5
                                            Known extended key usage bits are (defined in RFC 5280):
                                            serverAuth, clientAuth, codeSigning, emailProtection, timeStamping,
                                            msCodeInd, msCodeCom, msCTLSign, msSGC, msEFS, nsSGC


     -S [critical:]<san>                    subjectAltName extension. Prefix critical: can be used to set the critical
     --san=[critical:]<san>                 flag on the alternate name list (default: False).
                                            This is the same as --extension=subjectAltName,[0|1],,,<san>
                                            but as using the subjectAltName extension is the
                                            most common extension this is an extra option.

     -a                                     Mark certificate as auto renewable.
     --auto-renew                           The "housekeeping" command will take care of this

     -b critical:<data>                     Set basic constraints Prefix critical: can be used to set the critical
     --basic-constraint=critical:]<data>    flag on the basic constraints, e.g. -b critical:CA:TRUE,pathlen:1 for
                                            a CA certificate with a maximal path length of 1.

     -k [critical:]<flags>                  Comma separated list of keyUsage bits. Prefix critical: can be used to set
     --keyusage=[critical:]<flags>          the critical flag. Known keyUsage bits according to RFC 5280 are:
                                            digitalSignature, nonRepudiation (or contentCommitment), keyEncipherment,
                                            dataEncipherment, keyAgreement, keyCertSign, cRLSign, encipherOnly,
                                            decipherOnly (see RFC 5280, Section 4.2.1.3 "Key Usage" for futher details).

     -n                                     Don't store certificate data - except the serial number - in the database.
     --no-register                          The serial number is ALWAYS stored in the backend to avoid conflicting
                                            serial numbers of certificates (especially if the serial numbers are
                                            generated using "increment" strategy).

     -o <out>                               Write data to <outfile> instead of stdout
     --output=<out>

     -s <start>                             Validity of the new certificate starts in startin days.
     --start-in=<start>                     Default: now

     -t <template>                          Use a template file for certificate signing.
     --template=<template>

     -v <validfor>                          New certificate will be valid for validfor days.
     --valid-for=<validfor>                 Default ist the defined validity_period in the configuration or the
                                            template file.

   statistics                               Print small summary of stored certificates. Output will be written to
                                            stdout.

  """ % (os.path.basename(sys.argv[0]), configfile))


# unify a list but preserve the order
# http://www.peterbe.com/plog/uniqifiers-benchmark
def remove_duplicates(duplist):
    ordered = []

    for entry in duplist:
        if entry not in ordered:
            ordered.append(entry)

    return ordered


def list_certificates(opts, dbbackend, cfg):
    """
    List certificates from backend
    :param opts: options
    :param dbbackend: backend
    :param cfg: configuration
    :return:
    """
    output = None
    snfilter = []
    hexadecimal = False

    try:
        (optionval, optiontrailing) = getopt.getopt(opts, shortoptions["list"], longoptions["list"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    for (option, value) in optionval:
        if option in ("-o", "--output"):
            output = value
        elif option in ("-e", "--expired"):
            snfilter.append("expired")
        elif option in ("-i", "--invalid"):
            snfilter.append("invalid")
        elif option in ("-h", "--hex"):
            hexadecimal = True
        elif option in ("-r", "--revoked"):
            snfilter.append("revoked")
        elif option in ("-t", "--temporary"):
            snfilter.append("temporary")
        elif option in ("-v", "--valid"):
            snfilter.append("valid")
        else:
            __logger.error("Unknown option %s" % (option,))
            raise pkidbbackends.PKIDBException(message="Error: Unknown option %s" % (option,))

    if "global" in cfg:
        if "list_as_hex" in cfg["global"]:
            if cfg["global"]["list_as_hex"].strip().lower() == "true":
                hexadecimal = True
            elif cfg["global"]["list_as_hex"].strip().lower() == "false":
                hexadecimal = False
            else:
                __logger.error("Illegal value for list_as_hex, can be either True or False but not %s" %
                               (cfg["global"]["list_as_hex"], ))
                raise pkidbbackends.PKIDBException(message="Illegal value for list_as_hex, can be either True or False "
                                                           "but not %s" % (cfg["global"]["list_as_hex"], ))

    serials = []
    if len(snfilter) == 0:
        serials = dbbackend.list_serial_number_by_state(None)
    else:
        for state in snfilter:
            serials += dbbackend.list_serial_number_by_state(state)

    serials = remove_duplicates(serials)
    if hexadecimal:
        for i in range(len(serials)):
            serials[i] = "0x%.02x" % (long(serials[i]),)

    sn_dump = '\n'.join(serials)
    if output:
        try:
            fd = open(output, "w")
            fd.write(sn_dump)
            fd.close()
        except IOError as getopterror:
            __logger.error("Can't write to output file %s: %s" % (output, getopterror.strerror))
            raise pkidbbackends.PKIDBException(message="Can't write to output file %s: %s" %
                                                       (output, getopterror.strerror))
    else:
        sys.stdout.write(sn_dump + '\n')


def backup_database(opts, dbbackend):
    """
    Exports the database backend as JSON
    :param opts: options
    :param dbbackend: backend
    :return:
    """
    output = None

    try:
        (optionval, optiontrailing) = getopt.getopt(opts, shortoptions["backup"], longoptions["backup"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    for (option, value) in optionval:
        if option in ("-o", "--output"):
            output = value
        else:
            __logger.error("Unknown option %s" % (option,))
            raise pkidbbackends.PKIDBException(message="Error: Unknown option %s\n" % (option,))

    dump = dbbackend.dump_database()
    if not dump:
        __logger.warning("Database dump is empty")
        return None

    json_dump = json.dumps(dump)
    if output:
        try:
            fd = open(output, "w")
            fd.write(json_dump)
            fd.close()
        except IOError as getopterror:
            __logger.error("Can't write to output file %s: %s" % (output, getopterror.strerror))
            raise pkidbbackends.PKIDBException(message="Can't write to output file %s: %s" %
                                                       (output, getopterror.strerror))
    else:
        sys.stdout.write(json_dump + "\n")


def healthcheck(opts, dbbackend):
    fix = False

    try:
        (optionval, opttrailing) = getopt.getopt(opts, shortoptions["healthcheck"], longoptions["healthcheck"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    for (option, value) in optionval:
        if option in ("-f", "--fix"):
            fix = True
        else:
            __logger.error("Unknown option %s" % (option,))
            raise pkidbbackends.PKIDBException(message="Unknown option %s" % (option,))

    result = dbbackend.healthcheck(fix)

    total = len(result[0]) + len(result[1]) + len(result[2])
    found = len(result[1])
    repaired = len(result[2])

    __logger.info("%u certificates checked, %u problems found, %u problems repaired" % (total, found, repaired))


def restore_database(opts, dbbackend):
    """
    Restore a database from JSON dump
    :param opts: options
    :param dbbackend: backend
    :return:
    """
    inputdata = None
    try:
        (optionval, opttrailing) = getopt.getopt(opts, shortoptions["restore"], longoptions["restore"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    if len(opttrailing) == 1:
        inputdata = opttrailing[0]

    if inputdata:
        try:
            fd = open(inputdata, "r")
            json_data = fd.read()
            fd.close()
        except IOError as getopterror:
            __logger.error("Can't read from input file %s: %s" % (inputdata, getopterror.strerror))
            raise pkidbbackends.PKIDBException(message="Can't read from input file %s: %s" %
                                                       (inputdata, getopterror.strerror))

    else:
        json_data = sys.stdin.read()

    # convert JSON to data strucuture
    if json_data:
        try:
            data = json.loads(json_data)
        except ValueError as getopterror:
            __logger.error("Input is not valid JSON format: %s" % (getopterror.message,))
            raise pkidbbackends.PKIDBException(message="Input is not valid JSON format: %s" % (getopterror.message,))

        dbbackend.restore_database(data)


def set_certificate_metadata(opts, dbbackend):
    """
    Set certificate meta data in the backend.
    :param opts: options
    :param dbbackend: backend
    :return:
    """

    auto_renew = None
    auto_renew_start_period = None
    auto_renew_validity_period = None
    csr = None

    try:
        (optionval, opttrailing) = getopt.getopt(opts, shortoptions["set"], longoptions["set"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    for (option, value) in optionval:
        if option in ("-A", "--auto-renew"):
            auto_renew = True
        elif option in ("-a", "--no-auto-renew"):
            auto_renew = False
        elif option in ("-c", "--csr"):
            try:
                fd = open(value, "r")
                csrdata = fd.read()
                fd.close()
            except IOError as getopterror:
                __logger.error("Can't read certificate signing request from %s: %s" % (value, getopterror.strerror))
                raise pkidbbackends.PKIDBException(message="Can't read certificate signing request from %s: %s"
                                                           % (value, getopterror.strerror))

            csr = OpenSSL.crypto.load_certificate_request(OpenSSL.crypto.FILETYPE_PEM, csrdata)

        elif option in ("-P", "--auto-renew-start-period"):
            try:
                auto_renew_start_period = float(value)
            except ValueError as getopterror:
                __logger.error("Can't convert option to a number: %s" % (getopterror.message,))
                raise pkidbbackends.PKIDBException(message="Can't convert option to a number: %s" %
                                                           (getopterror.message,))

        elif option in ("-V", "--auto-renew-validity-period"):
            try:
                auto_renew_validity_period = float(value)
            except ValueError as getopterror:
                __logger.error("Can't convert option to a number: %s" % (getopterror.message,))
                raise pkidbbackends.PKIDBException("Can't convert option to a number: %s" % (getopterror.message,))

        else:
            __logger.error("Unknown option %s" % (option,))
            raise pkidbbackends.PKIDBException(message="Unknown option %s" % (option,))

    if len(opttrailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = opttrailing[0]

    serial = serial_to_number(serial)
    cert = dbbackend.set_certificate_metadata(serial, auto_renew=auto_renew,
                                              auto_renew_start_period=auto_renew_start_period,
                                              auto_renew_validity_period=auto_renew_validity_period, csr=csr)

    if not cert:
        __logger.error("No certificate with serial number %s found" % (serial,))
        raise pkidbbackends.PKIDBException(message="No certificate with serial number %s found" % (serial,))


def export_certificate(opts, dbbackend):
    """
    Export a certificate identified by the serial number
    :param opts: options
    :param dbbackend: backend
    :return:
    """
    output = None

    try:
        (optionval, opttrailing) = getopt.getopt(opts, shortoptions["export"], longoptions["export"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    for (option, value) in optionval:
        if option in ("-o", "--output"):
            output = value
        else:
            __logger.error("Unknown option %s" % (option,))
            raise pkidbbackends.PKIDBException("Unknown option %s" % (option,))

    if len(opttrailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = opttrailing[0]

    serial = serial_to_number(serial)
    cert = dbbackend.get_certificate(serial)

    if not cert:
        __logger.error("No certificate with serial number %s found" % (serial,))
        raise pkidbbackends.PKIDBException(message="No certificate with serial number %s found\n" % (serial,))

    pem_data = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)

    if output:
        try:
            fd = open(output, "w")
            fd.write(pem_data)
            fd.close()
        except IOError as getopterror:
            __logger.error("Can't write to output file %s: %s" % (output, getopterror.strerror))
            raise pkidbbackends.PKIDBException(message="Can't write to output file %s: %s" %
                                                       (output, getopterror.strerror))

    else:
        sys.stdout.write(pem_data)


def show_certificate(opts, dbbackend):
    """
    Shows certificate information identified by the serial number
    :param opts: options
    :param dbbackend: backend
    :return:
    """
    output = None

    try:
        (optionval, opttrailing) = getopt.getopt(opts, shortoptions["show"], longoptions["show"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    for (option, value) in optionval:
        if option in ("-o", "--output"):
            output = value
        else:
            __logger.error("Unknown option %s" % (option,))
            raise pkidbbackends.PKIDBException(message="Unknown option %s" % (option,))

    if len(opttrailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = opttrailing[0]

    serial = serial_to_number(serial)
    certdata = dbbackend.get_certificate_data(serial)

    if not certdata:
        __logger.error("No certificate with serial number %s found" % (serial,))
        raise pkidbbackends.PKIDBException(message="No certificate with serial number %s found" % (serial,))

    string = _print_data(certdata)

    if output:
        try:
            fd = open(output, "w")
            fd.write(string)
            fd.close()
        except IOError as getopterror:
            __logger.error("Can't write to output file %s: %s" % (output, getopterror.strerror))
            raise pkidbbackends.PKIDBException(message="Can't write to output file %s: %s" %
                                                       (output, getopterror.strerror))

    else:
        sys.stdout.write(string)


def _print_interval(interval):
    """
    Prints interval in seconds as string
    :param interval: interval in seconds
    :return: string
    """

    days = math.floor(interval / 86400)
    hours = math.floor((interval - 86400 * days) / 3600)
    minutes = math.floor((interval - 86400 * days - 3600 * hours) / 60)
    seconds = math.floor(interval - 86400 * days - 3600 * hours - 60 * minutes)

    string = "%u days %u hours %u minutes %.2f seconds" % (days, hours, minutes, seconds)
    return string


def _print_data(data):
    """
    Prints certificate date obtained by get_certificate_data
    :param data:
    :return: string
    """
    revinfo = ""
    if data["state"] == "revoked":
        revinfo = "\n * Revoked on: %s\n * Revocation reason: %s" % (data["revocation_date"], data["revocation_reason"])

    auto_renew_info = ""
    if data["auto_renewable"]:
        auto_renew_info = "\n * Auto renew starts before expiration: %s\n * Auto renew for: %s" % \
                          (_print_interval(data["auto_renew_start_period"]),
                           _print_interval(data["auto_renew_validity_period"]))

    ext_info = ""
    if len(data["extension"]) > 0:
        for i in range(len(data["extension"])):
            ext_info += "\n * Extension: %u\n  * Name: %s\n  * Critical: %s\n  * Data: %s" % \
                        (i + 1, data["extension"][i]["name"], data["extension"][i]["critical"],
                         data["extension"][i]["data"])

    result = """Serial number: %s
SSL version: %u
Key size: %u
Signature algorithm: %s
State: %s%s
Begins on: %s
Ends on: %s
Subject: %s
Issuer: %s
Fingerprint (MD5): %s
Fingerprint (SHA1): %s
Auto renewable: %s%s
Extensions: %u%s
Public key: %s
Certificate signing request: %s
""" % (data["serial_number"], data["version"], data["keysize"], data["algorithm"], data["state"], revinfo,
       data["start_date"], data["end_date"], data["subject"], data["issuer"], data["fingerprint_md5"],
       data["fingerprint_sha1"], data["auto_renewable"], auto_renew_info, len(data["extension"]), ext_info,
       data["certificate"], data["signing_request"])

    return result


def delete_certificate(opts, dbbackend):
    """
    Deletes a certificate identified by the serial number
    :param opts: options
    :param dbbackend: backend
    :return:
    """

    try:
        (optionval, opttrailing) = getopt.getopt(opts, shortoptions["delete"], longoptions["delete"])
    except getopt.GetoptError as dberror:
        __logger.error("Can't parse command line: %s" % (dberror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (dberror.msg,))

    if len(opttrailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = opttrailing[0]

    serial = serial_to_number(serial)

    if not dbbackend.has_serial_number(serial):
        __logger.error("No certificate with serial number %s found" % (serial,))
        raise pkidbbackends.PKIDBException(message="No certificate with serial number %s found" % (serial,))

    else:
        dbbackend.remove_certificate(serial)


def renew_certificate(opts, config, dbbackend):
    """
    Renew a certificate identified by the serial number
    :param opts: options
    :param config: configuration
    :param dbbackend: backend
    :return: None
    """

    validity_period = long(config["global"]["validity_period"])
    output = None

    try:
        (optionval, opttrailing) = getopt.getopt(opts, shortoptions["renew"], longoptions["renew"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    for (option, value) in optionval:
        if option in ("-p", "--period"):
            try:
                validity_period = float(value)
            except ValueError as getopterror:
                __logger.error("Can't parse validity period option %s: %s" % (value, getopterror.message))
                raise pkidbbackends.PKIDBException(message="Can't parse validity period option %s: %s"
                                                           % (value, getopterror.message))

        elif option in ("-o", "--output"):
            output = value
        else:
            __logger.error("Unknown option %s" % (option,))
            raise pkidbbackends.PKIDBException(message="Unknown option %s" % (option,))

    if len(opttrailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = opttrailing[0]

    serial = serial_to_number(serial)

    notbefore = time.time()
    notafter = notbefore + 86400. * validity_period

    notbefore = dbbackend.unix_timestamp_to_asn1_time(notbefore)
    notafter = dbbackend.unix_timestamp_to_asn1_time(notafter)

    ca_key = load_private_key(config, "ca_private_key", "ca_passphrase")

    newcert = dbbackend.renew_certificate(serial, notbefore, notafter, ca_key)

    if not newcert:
        raise pkidbbackends.PKIDBException(message="Can't renew certificate with serial number %s" % (serial,))

    pem_data = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, newcert)
    if output:
        try:
            fd = open(output, "w")
            fd.write(pem_data)
            fd.close()
        except IOError as getopterror:
            __logger.error("Can't write to output file %s: %s" % (output, getopterror.strerror))
            raise pkidbbackends.PKIDBException(message="Can't write to output file %s: %s" %
                                                       (output, getopterror.strerror))

    else:
        sys.stdout.write(pem_data)

    return None


def serial_to_number(serial):
    """
    Convert a string to the decimal value of serial number
    String can be a decimal number or hexadecimal (0x...)
    or hexadecimal separated by ":" (ca:fe:ba:be)
    :param serial: string containing serial number
    :return: decimal value of serial number string
    """
    re_serial_is_hex = re.compile("0x[0-9a-fA-F]+")

    # convert serial number to a number
    try:
        # check for 0x...
        if re_serial_is_hex.match(serial):
            serial = long(serial, 16)
        # it contains ":" we assume it is hexadecimal
        elif serial.find(":") >= 0:
            serial = serial.replace(":", "")
            serial = long(serial, 16)
        # assuming decimal value
        else:
            serial = long(serial)
    except ValueError as valerror:
        __logger.error("Can't convert serial number %s: %s" % (serial, valerror.message))
        raise pkidbbackends.PKIDBException(message="Can't convert serial number %s: %s" % (serial, valerror.message))

    return serial


def revoke_certificate(opts, dbbackend):
    """
    Revoke a certificate identified by the serial number
    :param opts: options
    :param dbbackend: backend
    :return: None
    """

    re_asn1_time_string = re.compile("^\d{14}Z$")
    force = False
    reason = "unspecified"
    rev_date = time.time()

    try:
        (optionval, opttrailing) = getopt.getopt(opts, shortoptions["revoke"], longoptions["revoke"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    for (option, value) in optionval:
        if option in ("-R", "--revocation-date"):
            # ASN1 GENERALIZEDTIME string?
            if re_asn1_time_string.match(value):
                # convert to UNIX timestamp
                rev_date = time.mktime(time.strptime(value, "%Y%m%d%H%M%SZ"))
            else:
                try:
                    rev_date = float(value)
                except ValueError as getopterror:
                    __logger.error("Can't parse end time %s: %s" % (value, getopterror.message))
                    raise pkidbbackends.PKIDBException(message="Can't parse end time %s: %s" %
                                                               (value, getopterror.message))

        elif option in ("-r", "--reason"):
            if dbbackend.get_revocation_reason_map(value.lower()) is not None:
                reason = value.lower()
            else:
                __logger.error("%s is not a valid revocation reason" % (value,))
                raise pkidbbackends.PKIDBException(message="%s is not a valid revocation reason" % (value,))

        elif option in ("-f", "--force"):
            force = True
        else:
            __logger.error("Unknown option %s" % (option,))
            raise pkidbbackends.PKIDBException(message="Error: Unknown option %s" % (option,))

    if len(opttrailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = opttrailing[0]

    serial = serial_to_number(serial)

    if not dbbackend.has_serial_number(serial) and not force:
        __logger.error("Certificate with serial number %s not found in database. If you want to revoke a certificate "
                       "by it's serial number that is not present in the database, use the force option." % (serial,))
        raise pkidbbackends.PKIDBException(message="Certificate with serial number %s not found in database. "
                                                   "If you want to revoke a certificate by it's serial number that is "
                                                   "not present in the database, use the force option." % (serial,))

    dbbackend.revoke_certificate(serial, reason, rev_date, force=force)


def generate_certificate_revocation_list(opts, config, dbbackend):
    """
    Generate certificate revocation list
    :param opts: options
    :param config: configurationd
    :param dbbackend: backend
    :return: None
    """

    output = None

    try:
        (opiontval, opttrailing) = getopt.getopt(opts, shortoptions["gencrl"], longoptions["gencrl"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException("Can't parse command line: %s" % (getopterror.msg,))

    for (option, value) in opiontval:
        if option in ("-o", "--output"):
            output = value
        else:
            __logger.error("Error: Unknown option %s" % (option,))
            raise pkidbbackends.PKIDBException("Unknown option %s" % (option,))

    # load CRL signing keys
    crl_pub_key = load_public_key(config, "crl_public_key")
    crl_priv_key = load_private_key(config, "crl_private_key", "crl_passphrase")

    crl = dbbackend.generate_revocation_list()

    crl_period = None
    if "crl_validity_period" in config["global"]:
        crl_period = long(config["global"]["crl_validity_period"])

    crl_data = None

    # CRL.export() parameter digest is available in pyopenssl 0.15
    if OpenSSL.__version__ >= "0.15":

        if "crl_digest" in config["global"]:
            crl_digest = config["global"]["crl_digest"]

            crl_data = crl.export(crl_pub_key, crl_priv_key, type=OpenSSL.crypto.FILETYPE_PEM,
                                  days=crl_period, digest=crl_digest)

    else:
        __logger.warning("Using an other digest for CRL signing than MD5 supported since version 0.15 of "
                         "pyOpenSSL (but this is %s). Falling back to MD5." % (OpenSSL.__version__,))
        crl_data = crl.export(crl_pub_key, crl_priv_key, type=OpenSSL.crypto.FILETYPE_PEM,
                              days=crl_period)

    if output:
        try:
            fd = open(output, "w")
            fd.write(crl_data)
            fd.close()
        except IOError as getopterror:
            __logger.error("Can't write CRL data to output file %s: %s" % (output, getopterror.strerror))
            raise pkidbbackends.PKIDBException(message="Can't write CRL data to output file %s: %s"
                                                       % (output, getopterror.strerror))
    else:
        sys.stdout.write(crl_data)


def sign_certificate(opts, config, dbbackend):
    """
    Sign a certificate signing request.
    :param opts: array with options
    :param config: parsed configuration file
    :param dbbackend: backend object
    :return: 0 on success or !=0 otherwise
    """

    output = None
    extensions = []
    notbefore = None
    valid_for = None
    templatedata = {"global": {}, "extension": [], }
    register_cert = True

    re_oid = re.compile("[0-9.]+")
    re_ca_flag = re.compile("CA:([A-Za-z]+)(.*)")

    try:
        (optionval, opttrailing) = getopt.getopt(opts, shortoptions["sign"], longoptions["sign"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    for (option, value) in optionval:
        if option in ("-E", "--extension"):
            ext = value.split(",", 4)
            if len(ext) != 5:
                __logger.error("Illegal number of fields for extension (expect:%u got %u)" % (4, len(ext)))
                raise pkidbbackends.PKIDBException(message="Illegal number of fields for extension (expect:%u got %u)"
                                                           % (4, len(ext)))

            name = ext[0]
            if ext[1] in ("1", "True"):
                critical = True
            else:
                critical = False

            if ext[2] == '':
                subject = None
            else:
                subject = ext[2]

            if ext[3] == '':
                issuer = None
            else:
                issuer = ext[3]

            data = ext[4]

            # append new extension object
            extensions.append(OpenSSL.crypto.X509Extension(name, critical, data, subject=subject, issuer=issuer))
        elif option in ("-S", "--san"):
            san = value
            critical = False
            if san.split(":", 1)[0].lower() == "critical":
                critical = True
                san = san.split(":", 1)[1]
            extensions.append(OpenSSL.crypto.X509Extension("subjectAltName", critical, san))
        elif option in ("-K", "--extended-keyusage"):
            extusage = value
            critical = False
            if extusage.split(":", 1)[0].lower() == "critical":
                critical = True
                extusage = extusage.split(":", 1)[1]

            extusagelist = extusage.split(",")
            for eusage in extusagelist:
                if dbbackend.get_extended_keyusage_list(eusage.strip().lower()) is None:
                    if not re_oid.match(eusage.strip()):
                        __logger.error("Invalid extended key usage %s" % (eusage,))
                        raise pkidbbackends.PKIDBException("Invalid extended key usage %s" % (eusage,))

            value = ",".join(extusagelist)
            extensions.append(OpenSSL.crypto.X509Extension("extendedKeyUsage", critical, value))

        elif option in ("-k", "--keyusage"):
            keyusage = value
            critical = False
            if keyusage.split(":", 1)[0].lower() == "critical":
                critical = True
                keyusage = keyusage.split(":", 1)[1]

            # map usage list to bit values as defined in RFC 5280
            usagelist = keyusage.split(",")

            for keyusage in usagelist:
                if dbbackend.get_keyusage_list(keyusage.strip().lower()) is None:
                    __logger.error("%s is not a valid key usage" % (keyusage,))
                    raise pkidbbackends.PKIDBException("%s is not a valid key usage" % (keyusage,))

            value = ",".join(usagelist)
            extensions.append(OpenSSL.crypto.X509Extension("keyUsage", critical, value))
        elif option in ("-b", "--basic-constraint"):
            basic = value
            critical = False
            if basic.split(":", 1)[0].lower() == "critical":
                critical = True
                basic = basic.split(":", 1)[1]

            # ASN1 expects boolean as FALSE or TRUE (not False, True, true, ...)
            # so for the sake of sanity check and convert flag to uppercase
            if re_ca_flag.match(basic):
                flag = re_ca_flag.match(basic).groups()[0]
                remainder = re_ca_flag.match(basic).groups()[1]
                if flag.lower() == "true":
                    flag = "TRUE"
                elif flag.lower() == "false":
                    flag = "FALSE"
                else:
                    __logger.error("%s is not a valid boolean flag" % (flag,))
                    raise pkidbbackends.PKIDBException(message="%s is not a valid boolean flag" % (flag,))

                # put them together again
                basic = "CA:%s%s" % (flag, remainder)

            extensions.append(OpenSSL.crypto.X509Extension("basicConstraints", critical, basic))

        elif option in ("-v", "--valid-for"):
            valid_for = value

            # convert to integer
            try:
                valid_for = int(valid_for)
            except ValueError as getopterror:
                __logger.error("Can't convert argument to an integer %s: %s" % (valid_for, getopterror.message))
                raise pkidbbackends.PKIDBException(message="Can't convert argument to an integer %s: %s" %
                                                           (valid_for, getopterror.message))

        elif option in ("-s", "--start-in"):
            notbefore = value

            try:
                notbefore = float(notbefore)
            except ValueError as getopterror:
                __logger.error("Can't convert argument to an integer %s: %s" % (notbefore, getopterror.message))
                raise pkidbbackends.PKIDBException(message="Can't convert argument to an integer %s: %s" %
                                                           (valid_for, getopterror.message))

        elif option in ("-t", "--template"):
            parsed = parseoptions(value)
            for key in parsed.keys():
                if key == "global":
                    templatedata["global"] = parsed["global"]
                else:
                    (ext, name) = key.split(":", 1)
                    if ext == "extension":
                        critical = False
                        if "critical" in parsed[key]:
                            critical = True

                        if "data" in parsed[key]:
                            data = parsed[key]["data"]
                        elif "data:base64" in parsed[key]:
                            data = base64.b64decode(parsed[key]["data:base64"])
                        else:
                            __logger.error("No data found in extension section %s" % (key,))
                            raise pkidbbackends.PKIDBException("No data found in extension section %s" % (key,))

                        subject = None
                        if "subject" in parsed[key]:
                            subject = parsed[key]["subject"]

                        issuer = None
                        if "issuer" in parsed[key]:
                            issuer = parsed[key]["issued"]

                        extdata = {
                            "name": name,
                            "critical": critical,
                            "data": data,
                            "subject": subject,
                            "issuer": issuer,
                        }
                        templatedata["extension"].append(extdata)

        elif option in ("-o", "--output"):
            output = value

        elif option in ("-n", "--no-register"):
            register_cert = False
        else:
            __logger.error("Unknown option %s" % (option,))
            raise pkidbbackends.PKIDBException(message="Error: Unknown option %s" % (option,))

    # data from template override global settings
    validity_period = int(config["global"]["validity_period"])
    digest = None
    if templatedata:
        if "validity_period" in templatedata["global"]:
            validity_period = int(templatedata["global"]["validity_period"])
        if "digest" in templatedata["global"]:
            digest = templatedata["global"]["digest"]

    # add extensions from template
    for ext in templatedata["extension"]:
        extensions.append(OpenSSL.crypto.X509Extension(ext["name"], ext["critical"], ext["data"], ext["subject"],
                                                       ext["issuer"]))
    if not notbefore:
        notbefore = 0

    if not valid_for:
        valid_for = validity_period

    if len(opttrailing) == 0:
        inputdata = sys.stdin

    elif len(opttrailing) == 1:
        try:
            inputdata = open(opttrailing[0], "r")
        except IOError as getopterror:
            __logger.error("Can't open %s for reading: %s" % (opttrailing[0], getopterror.strerror))
            raise pkidbbackends.PKIDBException(message="Can't open %s for reading: %s" %
                                                       (opttrailing[0], getopterror.strerror))

    else:
        __logger.error("Too much arguments. Expect zero or one, got %u instead" % (len(opttrailing),))
        raise pkidbbackends.PKIDBException(message="Too much arguments. Expect zero or one, got %u instead"
                                                   % (len(opttrailing),))

    # csr read data from input
    try:
        data = inputdata.read()
    except IOError as getopterror:
        __logger.error("Read from %s failed: %s" % (inputdata.name, getopterror.strerror))
        raise pkidbbackends.PKIDBException(message="Error: Read from %s failed: %s" %
                                                   (inputdata.name, getopterror.strerror))

    # close non stdin input
    if inputdata != sys.stdin:
        inputdata.close()

    # assuming PEM input
    csr = OpenSSL.crypto.load_certificate_request(OpenSSL.crypto.FILETYPE_PEM, data)

    # X509Req.get_extensions() is available in pyopenssl 0.15
    if OpenSSL.__version__ >= "0.15":
        # FIXME: Handle get_extensions()
        pass

    # load private CA key
    ca_priv_key = load_private_key(config, "ca_private_key", "ca_passphrase")
    if not ca_priv_key:
        __logger.error("Failed to load CA private key (Wrong password ?)")
        raise pkidbbackends.PKIDBException("Error: Failed to load CA private key (Wrong password?)")

    ca_pub_key = load_public_key(config, "ca_public_key")
    if not ca_pub_key:
        __logger.error("Failed to load CA public key")
        raise pkidbbackends.PKIDBException(message="Failed to load CA public key")

    # adjust start and and time

    # We do not pass the issuer of the CA, because only for root CA is issuer == subject
    # Intermediate CAs will contain their issuing CA as issuer
    newcert = dbbackend.sign_request(csr, notbefore, valid_for, ca_priv_key, ca_pub_key.get_subject(),
                                     extensions, register_cert, digest)

    newcert_pem = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, newcert)

    if output:
        try:
            fd = open(output, "w")
            fd.write(newcert_pem)
            fd.close()
        except IOError as getopterror:
            __logger.error("Can't open output file %s for writing: %s" % (output, getopterror.strerror))
            raise pkidbbackends.PKIDBException(message="Error: Can't open output file %s for writing: %s"
                                                       % (output, getopterror.strerror))

    else:
        sys.stdout.write(newcert_pem)


def load_public_key(config, keyname):
    """
    Loads issuer from CA public key
    :param config: configuration
    :param keyname: name of public key in [global] section
    :return: X509 object representing CA public key
    """

    try:
        fd = open(config["global"][keyname], "r")
        data = fd.read()
        fd.close()
    except IOError as ioerror:
        __logger.error("Can't read public key %s: %s" % (config["global"][keyname], ioerror.strerror,))
        raise pkidbbackends.PKIDBException(message="Can't read public key %s: %s"
                                                   % (config["global"][keyname], ioerror.strerror,))

    try:
        pubkey = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, data)
    except OpenSSL.crypto.Error as sslerror:
        __logger.error("Invalid public key: %s" % (sslerror.message,))
        raise pkidbbackends.PKIDBException(message="Error: Invalid public key: %s" % (sslerror.message,))

    return pubkey


def load_private_key(config, keyname, passphrase):
    """
    Load CA keyfile
    :param config: configuration
    :param keyname: name of private key in [global] section
    :param passphrase: name of passphrase variable in [global] section
    :return: private CA key as PKey object or None
    """

    key_passphrase = config["global"][passphrase]

    try:
        fd = open(config["global"][keyname], "r")
        data = fd.read()
        fd.close()
    except IOError as ioerror:
        __logger.error("Can't read private key %s: %s" % (config["global"][keyname], ioerror.strerror,))
        raise pkidbbackends.PKIDBException("Can't read private key %s: %s"
                                           % (config["global"][keyname], ioerror.strerror,))

    try:
        result = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, data, passphrase=key_passphrase)
    except OpenSSL.crypto.Error as sslerror:
        __logger.error("Can't load private key. Wrong password ? (%s)" % (sslerror.message,))
        raise pkidbbackends.PKIDBException(message="Can't load private key. Wrong password? (%s)" %
                                                   (sslerror.message,))

    return result


def import_certificate(opts, config, dbbackend):
    """
    Import a certificate (PEM) into the backend
    :param opts: options for import
    :param config: parsed configuration file
    :param dbbackend: backend object
    :return: 0 on success, != 0 otherwise
    """

    re_asn1_time_string = re.compile("^\d{14}Z$")
    try:
        (optionval, opttrailing) = getopt.getopt(opts, shortoptions["import"], longoptions["import"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    csr = None
    revoked = None
    autorenewable = False

    if "auto_renew_start_period" in config["global"]:
        auto_renew_start_period = float(config["global"]["auto_renew_start_period"])
    else:
        auto_renew_start_period = None

    for (option, value) in optionval:
        if option in ("-c", "--csr"):
            try:
                fd = open(value, "r")
                csrdata = fd.read()
                fd.close()
            except IOError as getopterror:
                __logger.error("Can't read certificate signing request from %s: %s" % (value, getopterror.strerror))
                raise pkidbbackends.PKIDBException(message="Can't read certificate signing request from %s: %s"
                                                           % (value, getopterror.strerror))

            csr = OpenSSL.crypto.load_certificate_request(OpenSSL.crypto.FILETYPE_PEM, csrdata)

        elif option in ("-r", "--revoked"):
            # format: <reason>,<revocation_stamp>
            (reason, revtime) = value.split(',')

            # ASN1 GENERALIZEDTIME string?
            if re_asn1_time_string.match(revtime):
                # convert to UNIX timestamp
                revtime = time.mktime(time.strptime(revtime, "%Y%m%d%H%M%SZ"))
            else:
                # check timestamp
                try:
                    revtime = float(revtime)
                except ValueError as valerror:
                    __logger.error("Illegal timestamp %s: %s" % (revtime, valerror.message))
                    raise pkidbbackends.PKIDBException(message="Illegal timestamp %s: %s" % (revtime, valerror.message))

            # treat no reason as unspecified
            if reason == '':
                reason = "unspecified"

            # check reason string
            if dbbackend.get_revocation_reason_map(reason.lower()) is not None:
                revoked = (dbbackend.get_revocation_reason_map(reason.lower()), revtime)

            elif option in ("-a", "--auto-renew"):
                autorenewable = True

        elif option in ("-p", "--period"):
            try:
                autorenew_period = float(value)
            except ValueError as getopterror:
                __logger.error("Can't parse validity period option %s: %s" % (value, getopterror.message))
                raise pkidbbackends.PKIDBException(message="Can't parse validity period option %s: %s"
                                                           % (value, getopterror.message))

        elif option in ("-d", "--delta"):
            try:
                auto_renew_start_period = float(value)
            except ValueError as getopterror:
                __logger.error("Can't parse delta period option %s: %s" % (value, getopterror.message))
                raise pkidbbackends.PKIDBException(message="Can't parse delta period option %s: %s"
                                                           % (value, getopterror.message))

    # discard autorenew_period if imported certificate is not marked as autorenewable
    if not autorenewable:
        autorenew_period = None
        auto_renew_start_period = None

    if len(opttrailing) == 0:
        inputdata = sys.stdin

    elif len(opttrailing) == 1:
        try:
            inputdata = open(opttrailing[0], "r")
        except IOError as getopterror:
            __logger.error("Can't open %s for reading: %s" % (opttrailing[0], getopterror.strerror))
            raise pkidbbackends.PKIDBException(message="Can't open %s for reading: %s" %
                                                       (opttrailing[0], getopterror.strerror))

    else:
        __logger.error("Too much arguments. Expect zero or one, got %u instead" % (len(opttrailing),))
        raise pkidbbackends.PKIDBException(message="Too much arguments. Expect zero or one, got %u instead"
                                                   % (len(opttrailing),))

    try:
        data = inputdata.read()
    except IOError as getopterror:
        __logger.error("Read from %s failed: %s" % (inputdata.name, getopterror.strerror))
        raise pkidbbackends.PKIDBException(message="Read from %s failed: %s" % (inputdata.name, getopterror.strerror))

    # close non stdin input
    if inputdata != sys.stdin:
        inputdata.close()

    # assuming PEM input
    cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, data)
    dbbackend.store_certificate(cert, csr, revoked, autorenew=autorenewable, validity_period=auto_renew_start_period)


def housekeeping(opts, dbbackend):
    """
    Check certificates in the backend for expiration, auto renew autorenewable certificates.
    :param opts: options for import
    :param dbbackend: backend object
    :return: None
    """
    try:
        (optionval, opttrailing) = getopt.getopt(opts, shortoptions["housekeeping"], longoptions["housekeeping"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    autorenew = False
    autorenew_period = None

    for (option, value) in optionval:
        if option in ("-a", "--auto-renew"):
            autorenew = True
        elif option in ("-p", "--period"):
            try:
                autorenew_period = float(value)
            except ValueError as getopterror:
                __logger.error("Can't parse autorenew period option %s: %s" % (value, getopterror.message))
                raise pkidbbackends.PKIDBException(message="Can't parse autorenew period option %s: %s"
                                                           % (value, getopterror.message))

    if not autorenew:
        autorenew_period = None

    dbbackend.housekeeping(autorenew=autorenew, validity_period=autorenew_period)

    return None


def remove_certificate(opts, dbbackend):
    """
    Remove certificate identified by the serial number.
    :param opts: options for import
    :param dbbackend: backend object
    :return: None
    """
    try:
        (optionval, opttrailing) = getopt.getopt(opts, shortoptions["remove"], longoptions["remove"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    if len(opttrailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = opttrailing[0]

    serial = serial_to_number(serial)

    dbbackend.remove_certificate(serial)


def print_statistics(dbbackend):
    """
    Print statistics of certificates in the backend database.
    :param dbbackend: backend object
    :return: None
    """
    try:
        pass
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    stats = dbbackend.get_statistics()

    for stat_type in stats:
        for key in stats[stat_type]:
            print("%s:%s:%u" % (stat_type, key, stats[stat_type][key]))

    return None


def _get_loglevel(string):
    """
    Returns value of loglevel for logging from string
    :param string: string
    :return: numeric loglevel
    """
    if string.lower() == "debug":
        return logging.DEBUG
    elif string.lower() == "info":
        return logging.INFO
    elif string.lower() == "warning":
        return logging.WARNING
    elif string.lower() == "warn":
        return logging.WARN
    elif string.lower() == "error":
        return logging.ERROR
    elif string.lower() == "critical":
        return logging.CRITICAL
    else:
        sys.stderr.write("Error: Unknown log level %s\n" % (string,))
        sys.exit(2)


def setup_logging(logoptions):
    """
    Setup logging based on the configuration setting
    :param logoptions: parsed config file
    :return: None
    """
    global __logger

    name = os.path.basename(sys.argv[0])
    logformat = logging.Formatter(name + " %(name)s:%(lineno)d %(levelname)s: %(message)s")

    re_logging = re.compile("(\w+),(\w+):(.*)$")
    if "logging" in logoptions:
        __logger = logging.getLogger("__main__")
        __logger.setLevel(logging.INFO)

        for log in logoptions["logging"]:
            if re_logging.match(logoptions["logging"][log]):
                (level, logtype, logopts) = re_logging.match(logoptions["logging"][log]).groups()

                if logtype.lower() == "file":
                    handler = logging.FileHandler(logopts)
                    handler.setLevel(_get_loglevel(level))
                    flogformat = logging.Formatter("%(asctime)s " + name +
                                                   " %(name)s:%(lineno)d %(levelname)s: %(message)s",
                                                   datefmt='%d %b %Y %H:%M:%S')
                    handler.setFormatter(flogformat)
                    __logger.addHandler(handler)
                elif logtype.lower() == "syslog":
                    handler = logging.handlers.SysLogHandler(address="/dev/log", facility=logopts.lower())
                    handler.setLevel(_get_loglevel(level))
                    handler.setFormatter(logformat)
                    __logger.addHandler(handler)
                else:
                    sys.stderr.write("Error: Unknown logging mechanism %s\n" % (logtype,))
    else:
        # set default logging
        # initialize logging subsystem
        address = '/dev/log'
        handler = logging.handlers.SysLogHandler(address=address)
        handler.setLevel(logging.INFO)
        handler.setFormatter(logformat)

        __logger.addHandler(handler)


def add_dummy(opts, dbbackend):
    """
    Add dummy certificate identified by it's serial number.
    :param opts: options for import
    :param dbbackend: backend object
    :return: None
    """

    notbefore = None
    notafter = None
    subject = None

    re_asn1_time_string = re.compile("^\d{14}Z$")

    try:
        (optionval, opttrailing) = getopt.getopt(opts, shortoptions["add-dummy"], longoptions["add-dummy"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    for (option, value) in optionval:
        if option in ("-s", "--start"):
            # ASN1 GENERALIZEDTIME string?
            if re_asn1_time_string.match(value):
                # convert to UNIX timestamp
                notbefore = time.mktime(time.strptime(value, "%Y%m%d%H%M%SZ"))
            else:
                try:
                    notbefore = float(value)
                except ValueError as valerror:
                    __logger.error("Can't parse start time %s: %s" % (value, valerror.message))
                    raise pkidbbackends.PKIDBException(message="Can't parse start time %s: %s" %
                                                               (value, valerror.message))

        elif option in ("-e", "--end"):
            # ASN1 GENERALIZEDTIME string?
            if re_asn1_time_string.match(value):
                # convert to UNIX timestamp
                notafter = time.mktime(time.strptime(value, "%Y%m%d%H%M%SZ"))
            else:
                try:
                    notafter = float(value)
                except ValueError as getopterror:
                    __logger.error("Can't parse end time %s: %s" % (value, getopterror.message))
                    raise pkidbbackends.PKIDBException(message="Can't parse end time %s: %s" %
                                                               (value, getopterror.message))

        elif option in ("-S", "--subject"):
            subject = value

    if len(opttrailing) == 0:
        serial = sys.stdin.read()
    else:
        serial = opttrailing[0]

    serial = serial_to_number(serial)

    if not subject:
        subject = "Placeholder, set for imported certificate with serial number %s" % (str(serial),)

    dbbackend.insert_empty_cert_data(serial, subject, notbefore, notafter)
    dbbackend.set_state(serial, "dummy")


def search_certificate(opts, dbbackend):
    """
    Search database for subject.
    :param opts: options for import
    :param dbbackend: backend object
    :return: None
    """

    try:
        (optionval, opttrailing) = getopt.getopt(opts, shortoptions["search"], longoptions["search"])
    except getopt.GetoptError as getopterror:
        __logger.error("Can't parse command line: %s" % (getopterror.msg,))
        raise pkidbbackends.PKIDBException(message="Can't parse command line: %s" % (getopterror.msg,))

    if len(opttrailing) == 0:
        searchstring = sys.stdin.read()
    else:
        searchstring = opttrailing[0]

    if searchstring and len(searchstring) > 0:
        result = dbbackend.search_certificate(searchstring)

        for res in result:
            sys.stdout.write("%s\n" % (long(res),))


def valid_mysql_config(mysql_cfg):
    """
    Check if the mysql configuration contains the required minimal options.
    :param mysql_cfg: MySQL configuration
    :return: True or False
    """
    mysql_options = mysql_cfg.keys()
    if ("host" in mysql_options) and \
            ("port" in mysql_options) and \
            ("database" in mysql_options) and \
            ("user" in mysql_options) and \
            ("passphrase" in mysql_options):

        # check for unknown configuration
        # remove known options
        mysql_options.remove("host")
        mysql_options.remove("port")
        mysql_options.remove("database")
        mysql_options.remove("user")
        mysql_options.remove("passphrase")

        if "sslcacert" in mysql_options:
            mysql_options.remove("sslcacert")

        if "sslcert" in mysql_options:
            mysql_options.remove("sslcert")

        if "sslkey" in mysql_options:
            mysql_options.remove("sslkey")

        if len(mysql_options) > 0:
            __logger.error("Unknown options for mysql backend: %s" % (",".join(mysql_options), ))
            return False

        return True
    else:
        __logger.error("Missing configuration for mysql backend.")
        return False


def valid_pgsql_config(pgsql_cfg):
    """
    Check if the pgsql configuration contains the required minimal options.
    :param pgsql_cfg: PostgreSQL configuration
    :return: True or False
    """
    pgsql_sslmode_list = ("disable", "allow", "prefer", "require", "verify-ca", "verify-full")

    pgsql_options = pgsql_cfg.keys()
    if ("host" in pgsql_options) and \
            ("port" in pgsql_options) and \
            ("database" in pgsql_options) and \
            ("user" in pgsql_options) and \
            ("passphrase" in pgsql_options):

        # check for unknown configuration
        # remove known options
        pgsql_options.remove("host")
        pgsql_options.remove("port")
        pgsql_options.remove("database")
        pgsql_options.remove("user")
        pgsql_options.remove("passphrase")

        if "sslcacert" in pgsql_options:
            pgsql_options.remove("sslcacert")

        if "sslcert" in pgsql_options:
            pgsql_options.remove("sslcert")

        if "sslkey" in pgsql_options:
            pgsql_options.remove("sslkey")

        if "sslmode" in pgsql_options:
            # check for valid sslmode settings
            if pgsql_cfg["sslmode"] not in pgsql_sslmode_list:
                __logger.error("Unknown sslmode for pgsql: %s" % (pgsql_cfg["sslmode"], ))
                return False

            pgsql_options.remove("sslmode")

        if len(pgsql_options) > 0:
            __logger.error("Unknown options for pgsql backend: %s" % (",".join(pgsql_options), ))
            return False

        return True
    else:
        __logger.error("Missing configuration for pgsql backend.")
        return False


def valid_sqlite3_config(sqlite3_cfg):
    """
    Check if the sqlite3 configuration contains the required minimal options.
    :param sqlite3_cfg: SQLite3 configuration
    :return: True or False
    """
    sqlite3_options = sqlite3_cfg.keys()
    if "database" not in sqlite3_options:
        __logger.error("Missing configuration for sqlite3 backend")
        return False

    return True


def valid_options(opts):
    """
    Basic validation of parsed options
    :param opts: dictionary containing basic options
    :return: True or False
    """
    # At least the global and a database backend should be defined
    if "global" not in opts:
        __logger.error("No global section found in configuration.")
        return False

    # A database backend should always be defined
    if "backend" not in opts["global"]:
        __logger.error("No backend found in configuration.")
        return False

    # check for supported backends
    if opts["global"]["backend"] not in ("mysql", "pgsql", "sqlite3"):
        __logger.error("Unsupported database backend %s" % (opts["global"]["backend"], ))
        return False
    else:
        # check if configuration contains the corresponding configuration section for the selected backend
        if opts["global"]["backend"] not in opts:
            __logger.error("Database backend %s found in global section but without configuration" %
                           (opts["global"]["backend"], ))
            return False
        else:
            # check minimal configuration depending on the database backend
            if opts["global"]["backend"] == "mysql":
                return valid_mysql_config(opts["mysql"])
            elif opts["global"]["backend"] == "pgsql":
                return valid_pgsql_config(opts["pgsql"])
            else:
                return valid_sqlite3_config(opts["sqlite3"])


def set_mysql_defaults(config):
    """
    Set default settings for MySQL backend
    :param config: dictionary of configuration
    :return: dictionary of configuration
    """
    if "mysql" in config:
        if "host" not in config["mysql"]:
            config["mysql"]["host"] = "localhost"

        if "port" not in config["mysql"]:
            config["mysql"]["port"] = "3306"

    return config


def set_pgsql_defaults(config):
    """
    Set default settings for PostgreSQL backend
    :param config: dictionary of configuration
    :return: dictionary of configuration
    """
    if "pgsql" in config:
        if "host" not in config["pgsql"]:
            config["pgsql"]["host"] = "localhost"

        if "port" not in config["pgsql"]:
            config["pgsql"]["port"] = "5432"

    return config


def set_sqlite3_defaults(config):
    """
    Set default settings for SQLite3 backend
    :param config: dictionary of configuration
    :return: dictionary of configuration
    """

    # No defaults for SQLite3
    return config


def set_missing_options_to_default(config):
    """
    Set missing values to default settings.
    :param config: dictionary containing configuration file
    :return: dictionary containing configuration with missing fields set to default values
    """

    if "global" in config:
        # set global defaults
        if "digest" not in config["global"]:
            config["global"]["digest"] = "sha512"

        if "serial_number" not in config["global"]:
            config["global"]["serial_number"] = "random"

        if "validity_period" not in config["global"]:
            config["global"]["validity_period"] = "1095"

        if "auto_renew_start_period" not in config["global"]:
            config["global"]["auto_renew_start_period"] = 14

        # CRL digest is MD5 instead more secure hashing algorithm because
        # pyOpenSSL <0.15 only supports md5
        if "crl_digest" not in config["global"]:
            config["global"]["crl_digest"] = "md5"

        if "crl_validity_period" not in config["global"]:
            config["global"]["crl_validity_period"] = "7"

        # set default logging
        if "logging" not in config:
            config["logging"] = {"default_logging": "info,syslog:user", }
        else:
            # section was in configuration file but it is empty
            if len(config["logging"].keys()) == 0:
                config["logging"] = {"default_logging": "info,syslog:user", }

        # set defaults for backends
        if "backend" in config["global"]:
            if config["global"]["backend"] == "mysql":
                config = set_mysql_defaults(config)
            elif config["global"]["backend"] == "pgsql":
                config = set_pgsql_defaults(config)
            elif config["global"]["backend"] == "sqlite3":
                config = set_sqlite3_defaults(config)

    return config


def set_configuration(config, section, key, value):
    """
    Set configuration key in section to value.
    :param config: configuration dictionary
    :param section: section
    :param key: key
    :param value: value
    :return: updated configuration dictionary
    """
    if section not in config:
        config[section] = {}

    config[section][key] = value
    return config


def merge_configuration_from_environment(config):
    """
    Insert configuration settings from environment in existing configuration.
    :param config: dictionary containing the current configuration
    :return: dictionary containing the configuration merged with settings from environment variables
    """
    env_keys = os.environ.keys()
    env_to_config_keys = environment_to_configuration.keys()
    for env_key in env_keys:
        if env_key in env_to_config_keys:
            section = environment_to_configuration[env_key]["section"]
            key = environment_to_configuration[env_key]["key"]
            value = os.environ[env_key]
            if section in config:
                if key in config[section]:
                    __logger.warning("%s:%s overwritten from environment variable %s." % (section, key, env_key))
            config = set_configuration(config, section, key, value)

        # handle PKIDB_LOGGING_* environment
        elif env_key.find("PKIDB_LOGGING_") == 0:
            section = "logging"
            key = env_key.replace("PKIDB_LOGGING_", "")
            value = os.environ[env_key]
            if section in config:
                if key in config[section]:
                    __logger.warning("%s:%s overwritten from environment variable %s." % (section, key, env_key))
            config = set_configuration(config, section, key, value)

    return config


def version():
    """
    Shows version.
    :return: None
    """
    print("""python-pkidb version %s
Copyright (C) 2015 - 2018 by Andreas Maus <maus@ypbind.de>
This program comes with ABSOLUTELY NO WARRANTY.

python-pkidb is distributed under the Terms of the GNU General
Public License Version 3. (http://www.gnu.org/copyleft/gpl.html)

""" % (__version__,))


def parse_site_configuration(optdict):
    """
    Check for defined sites in optdict, read(if defined and not empty)
    read site configuration and add it to optdict
    :param optdict: dictionary of options
    :return: dictionary of options with site configuration added
    """
    # build mapping site name -> site configuration
    sites = {}

    if "global" in optdict:
        if "sites" in optdict["global"]:
            site_list = optdict["global"]["sites"].strip().split()
            for sitedef in site_list:
                (site_name, site_config_file) = sitedef.split(":", )
                if site_name in sites:
                    __logger.warning("Site configuration for %s already defined, will be overwritten by "
                                     "new configuration" % (site_name, ))

                sites[site_name] = site_config_file

    for site in sites:
        site_configuration = parseoptions(sites[site])
        if site_configuration is not None:
            dict_key = "site:%s" % (site, )
            optdict[dict_key] = site_configuration

    return optdict


def merge_site_configuration(optdict, site):
    """
    Merge configuration for site
    :param optdict: dictionary of options
    :param site: site to merge
    :return: merged option dictionary
    """
    if site:
        dict_key = "site:%s" % (site, )
        if dict_key in optdict:
            # merge site specific configuration keys
            for site_key in optdict[dict_key]:
                optdict[site_key] = optdict[dict_key][site_key]
        else:
            __logger.error("No configuration found for requested site %s" % (site, ))
            raise pkidbbackends.PKIDBException(message="No configuration found for requested site %s" % (site, ))

    return optdict


def merge_alternative_names(optdict):
    """
    Merge alternative option names from configuration file into a single value
    :param optdict: dictionary of options
    :return: dictionary of options, alternative values merged (if present)
    """
    if "global" in optdict:
        if "ca_certificate" in optdict:
            optdict["global"]["ca_public_key"] = optdict["global"]["ca_certificate"]

    if "crl_certificate" in optdict:
        optdict["global"]["crl_public_key"] = optdict["global"]["crl_certificate"]

    return optdict


if __name__ == "__main__":
    failed = False
    selected_site = None

    # parse commandline options
    try:
        (optval, trailing) = getopt.getopt(sys.argv[1:], shortoptions["main"], longoptions["main"])
    except getopt.GetoptError as error:
        sys.stderr.write("Error: Can't parse command line: %s\n" % (error.msg,))
        sys.exit(1)

    for (opt, val) in optval:
        if opt in ("-h", "--help"):
            usage()
            sys.exit(0)
        elif opt in ("-c", "--config"):
            configfile = val
        elif opt in ("-s", "--site"):
            selected_site = val
        elif opt in ("-V", "--version"):
            version()
            sys.exit(0)
        else:
            sys.stderr.write("Error: Unknown option %s" % (opt,))
            sys.exit(1)

    if os.access(configfile, os.R_OK):
        # parse configuration file
        options = parseoptions(configfile)
    else:
        options = {}

    # read site configuration (if defined)
    options = parse_site_configuration(options)

    # merge settings from environment
    options = merge_configuration_from_environment(options)

    # set missing values to default values
    options = set_missing_options_to_default(options)

    # if a specific site is requested, merge its configuration
    if selected_site:
        options = merge_site_configuration(options, selected_site)
    else:
        # if a default_site has been defined merge configuration from
        # default site
        if "global" in options:
            if "default_site" in options["global"]:
                default_site = options["global"]["default_site"].strip()
                if default_site != "":
                    options = merge_site_configuration(options, default_site)

    options = merge_alternative_names(options)

    if not valid_options(options):
        __logger.error("Can't parse configuration.")
        raise pkidbbackends.PKIDBException("Can't parse configuration.")

    setup_logging(options)

    backend = None

    # create backend object
    if "backend" in options["global"]:
        if options["global"]["backend"] == "pgsql":
            import pkidbbackends.pgsql

            backend = pkidbbackends.pgsql.PostgreSQL(options)
        elif options["global"]["backend"] == "sqlite3":
            import pkidbbackends.sqlite

            backend = pkidbbackends.sqlite.SQLite(options)
        elif options["global"]["backend"] == "mysql":
            import pkidbbackends.mysql

            backend = pkidbbackends.mysql.MySQL(options)
        else:
            __logger.error("Unknown backend type %s" % (options["global"]["backend"],))
            sys.exit(1)
    else:
        __logger.error("No database backend defined.")
        sys.exit(1)

    if len(trailing) == 0:
        sys.stderr.write("Error: Missing command\n")
        __logger.error("Missing command")
        usage()
        sys.exit(1)

    command = trailing[0]
    start = time.time()

    try:
        if command == "sign":
            sign_certificate(trailing[1:], options, backend)
        elif command == "help":
            usage()
            sys.exit(0)
        elif command == "import":
            import_certificate(trailing[1:], options, backend)
        elif command == "housekeeping":
            housekeeping(trailing[1:], backend)
        elif command == "statistics":
            print_statistics(backend)
        elif command == "gencrl":
            generate_certificate_revocation_list(trailing[1:], options, backend)
        elif command == "revoke":
            revoke_certificate(trailing[1:], backend)
        elif command == "renew":
            renew_certificate(trailing[1:], options, backend)
        elif command == "export":
            export_certificate(trailing[1:], backend)
        elif command == "backup":
            backup_database(trailing[1:], backend)
        elif command == "list":
            list_certificates(trailing[1:], backend, options)
        elif command == "restore":
            restore_database(trailing[1:], backend)
        elif command == "delete":
            delete_certificate(trailing[1:], backend)
        elif command == "show":
            show_certificate(trailing[1:], backend)
        elif command == "set":
            set_certificate_metadata(trailing[1:], backend)
        elif command == "healthcheck":
            healthcheck(trailing[1:], backend)
        elif command == "add-dummy":
            add_dummy(trailing[1:], backend)
        elif command == "search":
            search_certificate(trailing[1:], backend)
        else:
            sys.stderr.write("Error: Unknown command %s\n" % (command,))
            __logger.error("Unknown command %s" % (command,))
            usage()
            sys.exit(1)
    except pkidbbackends.PKIDBException as pkidberror:
        sys.stderr.write("Error: Command %s failed: %s\n" % (command, pkidberror.message))
        __logger.error("Command %s failed: %s" % (command, pkidberror.message))
        failed = True

    stop = time.time()
    __logger.info("Command %s finished after %f seconds" % (command, (stop - start)))
    if failed:
        sys.exit(1)
    else:
        sys.exit(0)
